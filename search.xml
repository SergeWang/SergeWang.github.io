<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>What&#39;s &#39;static mean in Rust</title>
    <url>/2024/10/30/What&#39;s%20&#39;static%20mean%20in%20Rust/</url>
    <content><![CDATA[<p>In Rust, <code>'static</code> is a special lifetime that signifies that the data lives for the entire duration of the program. Here are some key points about <code>'static</code>:</p>
<h3 id="Key-Characteristics">Key Characteristics</h3>
<ol>
<li>
<p><strong>Longest Lifetime</strong>: The <code>'static</code> lifetime is the longest possible lifetime. Any data with a <code>'static</code> lifetime can be accessed anywhere in the program without worrying about it being dropped or going out of scope.</p>
</li>
<li>
<p><strong>String Literals</strong>: String literals have a <code>'static</code> lifetime because they are hardcoded into the program and exist for its entire runtime. For example:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Heap Allocated Data</strong>: Data allocated on the heap can also have a <code>'static</code> lifetime if it’s managed in a way that ensures it remains accessible for as long as needed. For example, using <code>Box</code> or <code>Rc</code> with <code>Arc</code> can create <code>'static</code> references:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, world!&quot;</span>); <span class="comment">// The Box itself is not &amp;&#x27;static</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(s); <span class="comment">// Now it&#x27;s &amp;&#x27;static</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Function Signatures</strong>: When a function or struct is defined with <code>'static</code>, it means it can hold or return data that will last for the entire duration of the program. For example:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_static_str</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Static Variables</strong>: Variables declared with the <code>static</code> keyword also have a <code>'static</code> lifetime. They are stored in a fixed memory location and exist for the entire lifetime of the program:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> GREETING: &amp;<span class="type">str</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Use-Cases">Use Cases</h3>
<ul>
<li>
<p><strong>Thread Safety</strong>: When working with threads, you often need to ensure that data can be safely accessed from multiple threads. Data with a <code>'static</code> lifetime can be sent across threads without fear of it being dropped unexpectedly.</p>
</li>
<li>
<p><strong>Long-Lived Resources</strong>: If you have resources that should be available throughout your application (like configuration settings), using data with a <code>'static</code> lifetime can be beneficial.</p>
</li>
</ul>
<h3 id="Summary">Summary</h3>
<p>The <code>'static</code> lifetime in Rust indicates that data is valid for the entire duration of the program, which is useful for ensuring safety in memory management, particularly when dealing with multithreading or long-lived resources.</p>
<p>Lifetimes in Rust are a crucial concept for managing how long references to data are valid. They help ensure memory safety without needing a garbage collector. Here’s an overview of lifetimes, their purpose, and how to use them effectively:</p>
<h3 id="Key-Concepts">Key Concepts</h3>
<ol>
<li>
<p><strong>Purpose of Lifetimes</strong>:</p>
<ul>
<li>Lifetimes are used to track how long references are valid. This prevents dangling references, where a reference points to data that has been freed or gone out of scope.</li>
<li>They help the Rust compiler enforce rules about how references can be used in functions and structures.</li>
</ul>
</li>
<li>
<p><strong>Basic Syntax</strong>:</p>
<ul>
<li>A lifetime is denoted by an apostrophe followed by a name (e.g., <code>'a</code>, <code>'b</code>).</li>
<li>When you specify a lifetime for a reference, it tells the compiler how long that reference is valid in relation to other references.</li>
</ul>
</li>
</ol>
<h3 id="Lifetime-Annotations">Lifetime Annotations</h3>
<p>Lifetime annotations are needed when:</p>
<ul>
<li>You have multiple references in a function, and the compiler needs to know how the lifetimes of those references relate to each other.</li>
</ul>
<h4 id="Example-of-Lifetime-Annotations">Example of Lifetime Annotations</h4>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s1: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, s2: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1.<span class="title function_ invoke__">len</span>() &gt; s2.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        s1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this example:</p>
<ul>
<li><code>&lt;'a&gt;</code> specifies that both <code>s1</code> and <code>s2</code> are references with the same lifetime <code>'a</code>.</li>
<li>The return type <code>-&gt; &amp;'a str</code> indicates that the returned reference will also have the same lifetime.</li>
</ul>
<h3 id="Lifetime-Elision">Lifetime Elision</h3>
<p>Rust has some rules to make using lifetimes easier through lifetime elision. This means that in certain situations, you don’t need to specify lifetimes explicitly:</p>
<ol>
<li>If there is exactly one input lifetime, it is inferred as the lifetime of the output.</li>
<li>If there are two input lifetimes, but one of them is <code>&amp;self</code> or <code>&amp;mut self</code>, the other is inferred as the lifetime of the output.</li>
</ol>
<p>Example with elision:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="comment">// Elided lifetimes: the function implicitly has lifetimes</span></span><br><span class="line">    <span class="comment">// as: fn first_word&lt;&#x27;a&gt;(s: &amp;&#x27;a str) -&gt; &amp;&#x27;a str</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Lifetime-Boundaries">Lifetime Boundaries</h3>
<ol>
<li>
<p><strong>Structs with Lifetimes</strong>: You can define structs that hold references, and you must annotate their lifetimes.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    title: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    author: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Lifetime Subtyping</strong>: A reference with a longer lifetime can be assigned to a reference with a shorter lifetime, but not vice versa. This is important in function parameters.</p>
</li>
</ol>
<h3 id="Common-Lifetime-Scenarios">Common Lifetime Scenarios</h3>
<ol>
<li>
<p><strong>Dangling References</strong>: Rust will not allow you to create dangling references. The compiler checks that any reference must always point to valid data.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bad_reference</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &amp;s <span class="comment">// Error: `s` is dropped here, making the reference invalid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>Multiple References</strong>: When a function takes multiple references, the lifetimes help the compiler understand the relationship between them.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">compare</span>&lt;<span class="symbol">&#x27;a</span>&gt;(a: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, b: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    a == b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Lifetime-Bounds">Lifetime Bounds</h3>
<p>You can use lifetime bounds to specify that certain lifetimes must outlive others:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">example</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(x: &amp;<span class="symbol">&#x27;a</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> T &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this function, the lifetime of the reference <code>x</code> is tied to the lifetime <code>'a</code>.</p>
<h3 id="Conclusion">Conclusion</h3>
<p>Lifetimes in Rust are an essential feature for ensuring safe memory management without a garbage collector. They enable the compiler to enforce rules about how references can be used, helping to prevent common bugs like dangling references and memory leaks. Understanding lifetimes is crucial for writing safe and efficient Rust code.</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>What&#39;s derive mean in Rust</title>
    <url>/2024/10/30/What&#39;s%20derive%20mean%20in%20Rust/</url>
    <content><![CDATA[<p>In Rust, the term “derive” typically refers to a procedural macro that automatically implements certain traits for your structs or enums. This feature helps reduce boilerplate code by generating implementations based on the structure of your types.</p>
<h3 id="Common-Usage-of-derive">Common Usage of <code>derive</code></h3>
<p>When you use the <code>#[derive(...)]</code> attribute above a struct or enum, you’re telling the Rust compiler to automatically generate implementations of specified traits. Some common traits that can be derived include:</p>
<ul>
<li><strong><code>Debug</code></strong>: Enables formatting the struct for debugging.</li>
<li><strong><code>Clone</code></strong>: Allows creating a copy of the struct.</li>
<li><strong><code>Copy</code></strong>: A marker trait for types that can be duplicated simply by copying bits (usually simple types).</li>
<li><strong><code>PartialEq</code></strong>: Enables comparison using <code>==</code> and <code>!=</code>.</li>
<li><strong><code>Eq</code></strong>: A marker trait for types that can be compared for equality.</li>
<li><strong><code>PartialOrd</code></strong>: Allows comparison using <code>&lt;</code>, <code>&gt;</code>, etc.</li>
<li><strong><code>Ord</code></strong>: A trait for types that have a total ordering.</li>
</ul>
<h3 id="Example">Example</h3>
<p>Here’s a simple example of using <code>derive</code> in Rust:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f64</span>,</span><br><span class="line">    y: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">2.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = p1.<span class="title function_ invoke__">clone</span>(); <span class="comment">// Using the derived Clone trait</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p1); <span class="comment">// Using the derived Debug trait</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(p1, p2); <span class="comment">// Using the derived PartialEq trait</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Custom-Derive-Macros">Custom Derive Macros</h3>
<p>You can also create your own custom derive macros to implement traits specific to your application. This involves writing a procedural macro that generates the appropriate code.</p>
<h3 id="Summary">Summary</h3>
<p>In summary, <code>derive</code> in Rust is a powerful feature that simplifies the implementation of common traits for your types, allowing for cleaner and more maintainable code.</p>
<p>In Rust, if you derive the <code>Default</code> trait for a struct or enum, it allows you to create a default value for that type. The <code>Default</code> trait provides a way to create a “default” instance of a type, which is useful when you want to initialize a struct or enum with default values.</p>
<h3 id="Using-derive-Default">Using <code>derive(Default)</code></h3>
<p>When you use <code>#[derive(Default)]</code>, Rust automatically generates an implementation of the <code>Default</code> trait for your type. The default value for each field is determined by its type’s own default.</p>
<h3 id="Example-2">Example</h3>
<p>Here’s a simple example:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f64</span>,</span><br><span class="line">    y: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">default_point</span> = Point::<span class="title function_ invoke__">default</span>(); <span class="comment">// Creates a Point with default values (x: 0.0, y: 0.0)</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, default_point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Behavior-of-Default">Behavior of Default</h3>
<ul>
<li>For primitive types like <code>f64</code>, the default value is <code>0.0</code>.</li>
<li>For <code>bool</code>, the default is <code>false</code>.</li>
<li>For <code>String</code>, the default is an empty string (<code>&quot;&quot;</code>).</li>
<li>For <code>Option&lt;T&gt;</code>, the default is <code>None</code>.</li>
</ul>
<h3 id="Custom-Default-Implementation">Custom Default Implementation</h3>
<p>If you want to specify custom default values, you can implement the <code>Default</code> trait manually instead of deriving it:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f64</span>,</span><br><span class="line">    y: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Default</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">default</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Point &#123; x: <span class="number">10.0</span>, y: <span class="number">20.0</span> &#125; <span class="comment">// Custom default values</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">custom_default_point</span> = Point::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, custom_default_point); <span class="comment">// Outputs: Point &#123; x: 10.0, y: 20.0 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Summary-2">Summary</h3>
<p>Using <code>#[derive(Default)]</code> simplifies creating default values for your types, while implementing the <code>Default</code> trait manually allows for more control over what those default values are.</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>主要扩散模型及其相关类别</title>
    <url>/2024/10/28/%E4%B8%BB%E8%A6%81%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%88%AB/</url>
    <content><![CDATA[<p><img src="/images/diffusion-models.png" alt="主要扩散模型"></p>
<!-- <iframe src="/pdf/dm.pdf" width="100%" height="600px"></iframe> -->
<h2 id="1-基于分数匹配的扩散模型">1.基于分数匹配的扩散模型</h2>
<p>● 噪声条件评分网络 (NCSN): 这是一种早期的基于分数匹配的扩散模型，它使用神经网络来学习数据分布的评分函数。<br>
● 潜空间评分生成模型 (LSGM): LSGM 使用变分自编码器 (VAE) 将数据压缩到潜空间，然后在潜空间中应用评分匹配来学习数据分布。<br>
● 基于分数的随机微分方程 (Score-SDE): Score-SDE 使用随机微分方程 (SDE) 来描述扩散过程，并使用神经网络来学习 SDE 的漂移项，该漂移项与数据分布的评分函数相关。<br>
● ScoreFlow: ScoreFlow 通过最大化似然函数的上界来训练基于分数的扩散模型。</p>
<h2 id="2-潜变量模型">2.潜变量模型</h2>
<p>● 潜扩散模型 (LDM): LDM 使用预训练的 VAE 将图像压缩到潜空间，然后在潜空间中应用扩散模型来生成图像。这种方法可以提高训练和推理效率，并生成更高质量的图像。</p>
<h2 id="3-条件引导的扩散模型">3.条件引导的扩散模型</h2>
<p>● 引导扩散 (GLIDE): GLIDE 使用分类器引导来控制扩散模型的生成过程，使其生成符合特定条件的图像。<br>
● 分类器引导扩散 (CfDG): CfDG 是一种改进的分类器引导方法，它可以更有效地将条件信息整合到扩散模型中。<br>
● 稳定扩散 (Stable Diffusion): Stable Diffusion 是一种流行的文本到图像扩散模型，它使用 LDM 和 CfDG 来生成高质量的图像。</p>
<h2 id="4-基于-Transformer-的扩散模型">4.基于 Transformer 的扩散模型</h2>
<p>● U-ViT: U-ViT 将 Transformer 模块引入到 U 形结构中，作为扩散模型的主干网络，它将所有输入视为 token，并在浅层和深层之间使用长跳跃连接。<br>
● 扩散 Transformer (DiT): DiT 使用视觉 Transformer (ViT) 作为主干网络来代替 U-Net，并进一步证明了 Transformer 在图像生成任务中的可扩展性。<br>
● PixArt-α: PixArt-α 简化了扩散 Transformer 中计算密集的类条件分支，方法是加入交叉注意模块来注入通过 T5 编码的文本条件。</p>
<h2 id="5-基于状态空间模型-SSM-的扩散模型">5.基于状态空间模型 (SSM) 的扩散模型</h2>
<p>● Mamba: Mamba 结合了 SSM 架构，并提出了硬件感知算法，可实现高效的训练和推理。<br>
● DiM: DiM 引入 Mamba 作为扩散主干网络，用于生成高分辨率图像。<br>
● ZigMa: ZigMa 通过在图像中加入基于连续性的归纳偏差，使 Mamba 模块适用于二维图像，并通过执行三维序列的时空分解，将其扩展到视频生成任务。<br>
类别之间的关系:<br>
这些类别之间存在着一些联系。例如，许多基于分数匹配的扩散模型也使用了潜变量模型，例如 LSGM 和 LDM。条件引导的扩散模型可以使用各种主干网络，包括基于 U-Net、Transformer 或 SSM 的网络。</p>
]]></content>
      <categories>
        <category>Diffusion Model</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>人工智能</tag>
        <tag>扩散模型</tag>
      </tags>
  </entry>
  <entry>
    <title>从GANs到扩散模型到自回归模型</title>
    <url>/2024/10/30/%E4%BB%8EGANs%E5%88%B0%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B%E5%88%B0%E8%87%AA%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="扩散模型胜过-GAN-的原因">扩散模型胜过 GAN 的原因</h3>
<ul>
<li><strong>更易于缩放和训练</strong>：与 GAN 相比，扩散模型通常更容易缩放和训练。这是因为 GAN 存在臭名昭著的训练不稳定性，并且可能难以捕获数据分布的全部多样性。</li>
<li><strong>更好的分布覆盖率</strong>：扩散模型能够更好地覆盖数据分布，从而产生更多样化的样本。GAN 通常会牺牲多样性来换取保真度，从而导致样本质量高但无法涵盖整个分布。</li>
<li><strong>静态训练目标</strong>：扩散模型具有静态训练目标，这使得它们更容易优化。另一方面，GAN 具有对抗性训练目标，这可能导致训练动态不稳定。</li>
</ul>
<h3 id="自回归模型胜过扩散模型的原因">自回归模型胜过扩散模型的原因</h3>
<ul>
<li><strong>与大型语言模型 (LLM) 的范式一致</strong>：自回归模型与 LLM 使用相同的“下一个标记预测”范式。这使得使用 LLM 的进步来改进自回归图像生成模型成为可能。</li>
<li><strong>潜在的统一语言和视觉模型</strong>：自回归方法有可能在语言和视觉之间建立统一的模型。扩散模型具有与自回归语言模型不同的范式，这给建立语言和视觉的统一模型带来了巨大的挑战。</li>
<li><strong>利用 LLM 框架的优势</strong>：自回归模型可以利用 LLM 社区开发的技术来优化训练方法和推理速度。</li>
</ul>
<h3 id="三种模型的核心思想、模型架构和主要进展">三种模型的核心思想、模型架构和主要进展</h3>
<h4 id="生成对抗网络-GAN">生成对抗网络 (GAN)</h4>
<ul>
<li><strong>核心思想</strong>：GAN 由两个神经网络组成：生成器和判别器。生成器学习从随机噪声中生成数据，而判别器学习区分生成数据和真实数据。两个网络在对抗性过程中一起训练，生成器试图欺骗判别器，而判别器试图正确地对数据进行分类。</li>
<li><strong>模型架构</strong>：GAN 的架构可以根据具体应用而变化。生成器通常采用反卷积网络，而判别器通常采用卷积网络。</li>
<li><strong>损失函数</strong>：生成对抗网络 (GAN): GAN 的核心损失函数是对抗性损失。对抗性损失是基于判别器的输出计算的。判别器的目标是正确区分真实数据和生成数据。生成器的目标是生成能够欺骗判别器的数据。因此，对抗性损失函数的设计是为了最大化判别器在真实数据上的输出，同时最小化判别器在生成数据上的输出。</li>
<li><strong>主要进展</strong>：近年来，GAN 取得了许多进展，包括渐进式生长、风格化 GAN 和 BigGAN。这些进展提高了 GAN 生成的样本的质量和多样性。</li>
</ul>
<h4 id="扩散模型">扩散模型</h4>
<ul>
<li><strong>核心思想</strong>：扩散模型通过逆转一个逐渐加噪的过程来从分布中采样。该模型通过逐步从信号中去除噪声来生成样本，其训练目标可以表示为重新加权的变分下界。</li>
<li><strong>模型架构</strong>：扩散模型通常使用 UNet 架构，该架构由一系列残差层和下采样卷积组成，然后是一系列具有上采样卷积的残差层，跳过连接连接具有相同空间大小的层。</li>
<li><strong>损失函数</strong>：扩散模型的核心损失函数是去噪分数匹配 (DSM) 或均方误差 (MSE) 损失。DSM 损失函数是基于模型在不同噪声水平下预测数据分数的准确性计算的。 MSE 损失函数用于训练模型预测噪声图像中的噪声分量。 两种方法都旨在训练模型逐步去除噪声并生成高质量样本。</li>
<li><strong>主要进展</strong>：扩散模型的最新进展包括改进的 UNet 架构、分类器引导 和上采样扩散模型。这些进展提高了扩散模型生成的样本的质量和效率。</li>
</ul>
<h4 id="自回归模型">自回归模型</h4>
<ul>
<li><strong>核心思想</strong>：自回归模型通过预测序列中的下一个标记来生成数据。在图像生成中，图像首先被标记化，然后自回归模型逐个标记地生成图像标记。</li>
<li><strong>模型架构</strong>：自回归图像生成模型通常使用类似于 LLM 的架构，例如 Llama。</li>
<li><strong>损失函数</strong>：自回归模型的核心损失函数是交叉熵损失。交叉熵损失函数用于衡量模型预测的概率分布与真实数据分布之间的差异。在自回归图像生成中，该损失函数用于衡量模型预测的下一个图像标记的概率分布与真实下一个图像标记的概率分布之间的差异。</li>
<li><strong>主要进展</strong>：自回归图像生成模型的最新进展包括改进的图像标记器、可扩展图像生成模型 和使用 LLM 训练技术。这些进展提高了自回归模型生成的样本的质量和效率。</li>
</ul>
<p>不同的模型架构，例如 GAN 中的生成器和判别器网络结构、扩散模型中 UNet 的深度和宽度、自回归模型中 Transformer 的层数和注意力头数，都会影响模型的参数量和大小。GAN 的大小可以变化很大，从几百万个参数到数十亿个参数不等。这取决于具体的 GAN 架构和应用。扩散模型通常比 GAN 大，参数量从数百万到数十亿不等。近年来，一些大型扩散模型的参数量已经超过了百亿。自回归模型的规模也可能很大，尤其是用于图像生成的模型。一些基于 Transformer 的自回归模型的参数量也已经超过了百亿。</p>
]]></content>
      <categories>
        <category>Diffusion Model</category>
      </categories>
      <tags>
        <tag>扩散模型</tag>
        <tag>自回归模型</tag>
        <tag>生成对抗模型</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 CNF 中时间依赖微分同胚映射的理解</title>
    <url>/2024/10/28/%E5%85%B3%E4%BA%8E-CNF-%E4%B8%AD%E6%97%B6%E9%97%B4%E4%BE%9D%E8%B5%96%E5%BE%AE%E5%88%86%E5%90%8C%E8%83%9A%E6%98%A0%E5%B0%84%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="/images/bird-wings-flying-feature.gif" alt="关于 CNF 中时间依赖微分同胚映射的理解"></p>
<p>在连续归一化流 (CNF) 中，时间依赖微分同胚映射是将简单分布（如标准正态分布）转化为复杂数据分布的关键机制。它通过一个随时间变化的向量场 \(v_t(x)\) 来实现，这个向量场决定了概率密度函数从初始分布 \(p_\theta(x)\) 到目标分布 \(p_1(x)\) 的演化过程。这个演化过程可以通过一个微分同胚映射 \(\phi_t\) 来描述，它将时间 \(t\) 的概率密度函数 \(p_t(x)\)  “推” 向时间 \(t+dt\) 的概率密度函数 \(p_{t+dt}(x)\)。</p>
<h3 id="微分同胚映射的定义">微分同胚映射的定义</h3>
<p>微分同胚映射 \(\phi_t\) 拥有以下性质：</p>
<ul>
<li><strong>双射:</strong>  \(\phi_t\) 是一个一一映射，也就是说，对于每一个 x，都有唯一一个 y 与之对应，反之亦然。</li>
<li><strong>可微:</strong>  \(\phi_t\) 和它的逆映射 \(\phi_t^{−1}\)  都是可微的，这意味着它们是光滑且连续的。</li>
<li><strong>保向:</strong>  \(\phi_t\) 保持空间的方向，也就是说，它不会翻转或扭曲空间。</li>
</ul>
<p>这些性质保证了 \(\phi_t\) 可以将一个概率密度函数平滑地转化为另一个概率密度函数，并且不会丢失任何信息。</p>
<h3 id="微分同胚映射的构建">微分同胚映射的构建</h3>
<p>微分同胚映射 \(\phi_t\) 是通过求解以下常微分方程 (ODE) 得到的:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><msub><mi>ϕ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>v</mi><mi>t</mi></msub><mo stretchy="false">(</mo><msub><mi>ϕ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\frac{d}{dt} \phi_t(x) = v_t(\phi_t(x)) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>ϕ</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\phi_0(x) = x
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span></p>
<p>其中 \(v_t(x)\) 是 CNF 模型学习到的时间依赖向量场。这个 ODE 描述了在向量场 \(v_t(x)\) 的作用下，点 \(x\) 随时间的运动轨迹。\(\phi_tt(x)\)  则表示从初始时刻 \(t=0\) 开始，沿着这条轨迹运动到时间 \(t\) 时所到达的点。</p>
<h3 id="连续性方程的作用">连续性方程的作用</h3>
<p>连续性方程可以用来验证向量场  \(v_t(x)\) 是否能够正确地引导概率密度函数的演化。它表明概率密度的变化率必须与其“流动”情况相互抵消，以保证总概率守恒。</p>
<h3 id="总结">总结</h3>
<p>时间依赖微分同胚映射是 CNF 模型的核心概念之一，它通过一个随时间变化的向量场来实现概率密度函数的平滑转化。连续性方程则确保了这个转化过程的有效性。</p>
]]></content>
      <categories>
        <category>Diffusion Model</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>人工智能</tag>
        <tag>扩散模型</tag>
      </tags>
  </entry>
  <entry>
    <title>对连续性方程的深入解读</title>
    <url>/2024/10/28/%E5%AF%B9%E8%BF%9E%E7%BB%AD%E6%80%A7%E6%96%B9%E7%A8%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>连续性方程本质上是一个描述守恒量的方程。在流匹配的语境下，这个守恒量就是概率密度。</p>
<h3 id="概率密度的守恒">概率密度的守恒</h3>
<p>想象一下液体在管道中流动。如果液体不可压缩，那么无论管道粗细如何变化，单位时间内流过任何一个截面的液体总量都应该保持不变。这就是质量守恒定律的体现。</p>
<p>概率密度也遵循类似的守恒原则。假设我们有一个概率密度函数 \(p_t(x)\)，它描述了在时间 \(t\) 时，随机变量 \(X\) 取值 \(x\) 的概率密度。随着时间的推移，\(p_t(x)\) 的形状可能会发生变化，但它所代表的总概率必须保持为 1。</p>
<p>连续性方程正是用来描述概率密度这种守恒特性的数学工具。</p>
<h3 id="连续性方程的数学表达">连续性方程的数学表达</h3>
<p>连续性方程的表达式如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><msub><mi>p</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>v</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msub><mi>v</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\frac{d}{dt} p_t(x) + div(p_t(x)v_t(x)) = 0 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span></p>
<ul>
<li><strong>\(\frac{d}{dt} p_t(x)\)</strong> 表示概率密度函数 \(p_t(x)\) 随时间的变化率。</li>
<li><strong>\(div(p_t(x)v_t(x))\)</strong> 表示概率密度的“流动”情况，其中 \(v_t(x)\) 是一个向量场，描述了概率密度在空间中的运动方向和速度。散度算子 \(div\) 则度量了向量场在某一点的“扩张”或“收缩”程度。</li>
</ul>
<p><strong>连续性方程的意义：</strong></p>
<ul>
<li>如果 \(\frac{d}{dt} p_t(x)\) 为正，说明在 x 点的概率密度正在增加，这可能是由于周围的概率密度流入了 \(x\) 点。</li>
<li>如果 \(div(p_t(x)v_t(x))\) 为负，说明在 x 点的概率密度正在减少，这可能是由于 \(x\) 点的概率密度流向了周围。</li>
</ul>
<p>连续性方程指出，概率密度的变化率与概率密度的“流动”情况必须相互抵消，以保证总概率守恒。</p>
<h3 id="连续性方程在流匹配中的应用">连续性方程在流匹配中的应用</h3>
<p>在流匹配中，我们希望训练一个连续归一化流 (CNF) 模型，使其能够生成与目标数据分布相似的样本。这个 CNF 模型可以用一个向量场 \(v_t(x)\) 来表示，它决定了概率密度函数从初始分布 \(p_0(x)\) 到目标分布 \(p_1(x)\) 的演化过程。</p>
<p>连续性方程的作用就是确保 CNF 模型所定义的向量场 \(v_t(x)\) 能够正确地引导概率密度函数的演化，并最终生成我们期望的目标分布。</p>
<p><strong>具体来说，连续性方程的应用体现在以下几个方面：</strong></p>
<ol>
<li><strong>验证模型的有效性：</strong> 通过检查学习到的向量场 \(v_t(x)\) 是否满足连续性方程，我们可以判断 CNF 模型是否能够生成有效的概率路径。</li>
<li><strong>设计训练目标函数：</strong>  一些流匹配的训练目标函数的设计是基于连续性方程的。例如，条件流匹配 (CFM) 的目标函数就是为了最小化模型向量场与目标向量场之间的差异，而目标向量场的构建正是基于连续性方程。</li>
<li><strong>计算模型的概率密度：</strong> 利用连续性方程和流的轨迹方程，我们可以推导出计算 CNF 模型在任意数据点概率密度的方法。</li>
</ol>
<h3 id="总结">总结</h3>
<p>连续性方程是理解流匹配的关键概念之一。它提供了一种数学工具来描述概率密度的守恒特性，并确保 CNF 模型能够生成有效的概率路径。</p>
]]></content>
      <categories>
        <category>Diffusion Model</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>人工智能</tag>
        <tag>扩散模型</tag>
      </tags>
  </entry>
  <entry>
    <title>流匹配 (Flow Matching) 简介</title>
    <url>/2024/10/28/%E6%B5%81%E5%8C%B9%E9%85%8D%20(Flow%20Matching)%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>流匹配 (FM) 是一种用于训练连续归一化流 (CNF) 的新方法，它能够以空前的规模训练 CNF。它基于一种称为“条件概率路径”的概念，该路径描述了从噪声样本到数据样本的转换过程。FM 的目标是通过回归固定条件概率路径的向量场来匹配该目标概率路径，而无需进行昂贵的模拟。</p>
<h3 id="条件流匹配-CFM">条件流匹配 (CFM)</h3>
<p>为了使 FM 更加易于处理，引入了条件流匹配 (CFM) 的概念。CFM 避免了对难以处理的积分的依赖，并使用每个样本定义的概率路径和向量场。</p>
<p><strong>CFM 目标函数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LCFM(θ) = Et,q(x1),p(x0) ||| vt(ψt(x0)) - d/dt ψt(x0) |||² </span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>θ 是 CNF 向量场的可学习参数。</li>
<li>t ∼ U（均匀分布）。</li>
<li>x1 是服从未知数据分布 q(x1) 的随机变量。</li>
<li>x0 ∼ p(x0) 是服从简单分布的随机变量，例如标准正态分布。</li>
<li>ψt 是与条件概率路径 pt(x|x1) 对应的流映射。</li>
<li>vt 是 CNF 向量场。</li>
</ul>
<p><strong>CFM 的优势：</strong></p>
<ul>
<li>与原始 FM 目标函数具有相同的最佳值。</li>
<li>不需要显式了解难以处理的目标向量场。</li>
</ul>
<h3 id="条件概率路径和向量场">条件概率路径和向量场</h3>
<p>CFM 适用于任何条件概率路径和条件向量场。常用的方法是使用高斯条件概率路径。</p>
<p><strong>高斯条件概率路径：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pt(x|x1) = N(x|µt(x1), σ²t(x1)I)</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>µt(x1) 是时间 t 的条件均值。</li>
<li>σ²t(x1) 是时间 t 的条件方差。</li>
<li>I 是单位矩阵。</li>
</ul>
<p><strong>条件向量场：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ut(x|x1) = σ&#x27;t(x1) / σt(x1) (x - µt(x1)) + µ&#x27;t(x1)</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>σ’t(x1) 是 σt(x1) 对时间 t 的导数。</li>
<li>µ’t(x1) 是 µt(x1) 对时间 t 的导数。</li>
</ul>
<h3 id="扩散路径与最优传输-OT-路径">扩散路径与最优传输 (OT) 路径</h3>
<p>扩散路径和最优传输 (OT) 路径是两种常见的用于定义条件概率路径的方法。</p>
<p><strong>扩散路径：</strong></p>
<p>扩散路径使用随机微分方程来定义概率路径。然而，扩散路径可能会导致弯曲的采样轨迹，并且在训练过程中采样成本可能会发生巨大变化。</p>
<p><strong>OT 路径：</strong></p>
<p>OT 路径使用最优传输理论来定义概率路径。OT 路径下的粒子始终以恒定速度沿直线轨迹移动。与扩散路径相比，OT 路径具有以下优势：</p>
<ul>
<li>更简单的采样轨迹</li>
<li>更快的训练速度</li>
<li>更快的生成速度</li>
<li>更好的性能</li>
</ul>
<h3 id="流匹配的应用">流匹配的应用</h3>
<p>流匹配已成功应用于各种生成建模任务，例如：</p>
<ul>
<li>图像生成</li>
<li>视频生成</li>
<li>音频生成</li>
</ul>
<p><strong>流匹配的优势：</strong></p>
<ul>
<li>可扩展到非常高维度。</li>
<li>提供了一种关于扩散模型的替代观点。</li>
<li>允许更直接地指定概率路径，从而实现更快的采样和/或改进生成。</li>
<li>在训练和采样方面都很容易。</li>
</ul>
<p><strong>总结:</strong></p>
<p>流匹配是一种用于训练连续归一化流的强大技术。它提供了一种灵活且可扩展的框架，用于学习从简单分布到复杂数据分布的转换。通过利用条件概率路径和向量场，流匹配避免了昂贵的模拟，并实现了高效的训练和采样。</p>
]]></content>
      <categories>
        <category>Diffusion Model</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>人工智能</tag>
        <tag>扩散模型</tag>
      </tags>
  </entry>
  <entry>
    <title>计算CNF模型概率的方法</title>
    <url>/2024/10/28/%E8%AE%A1%E7%AE%97CNF%E6%A8%A1%E5%9E%8B%E6%A6%82%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>连续归一化流 (CNF) 模型通过一个时间依赖的微分同胚映射将简单分布（如标准正态分布）转化为复杂数据分布。要计算 CNF 模型在任意数据点 \(x_1\) 的概率，我们需要利用连续性方程和流的轨迹方程。</p>
<h3 id="连续性方程和概率密度的变化">连续性方程和概率密度的变化</h3>
<p>连续性方程描述了概率密度的守恒特性：</p>
<!-- <p>
  When \(a \ne 0\), there are two solutions to \(ax^2 + bx + c = 0\) and they are
  \[x = {-b \pm \sqrt{b^2-4ac} \over 2a}.\]
</p> -->
<!-- \\(\mathcal{F}(x)=\mathcal{H}(x)-x\\) -->
<!-- $$\lim_{n\rightarrow \infty}(1+2^n+3^n)^\frac{1}{x+\sin n}$$ -->
<!-- <p>
\[\frac{d}{dt}p_t(x) + div(p_t(x)v_t(x)) = 0\]
</p> -->
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><msub><mi>p</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>v</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msub><mi>v</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\frac{d}{dt}p_t(x) + div(p_t(x)v_t(x)) = 0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>其中：</p>
<ul>
<li>\(p_t(x)\) 是时间 t 的概率密度函数。</li>
<li>\(v_t(x)\) 是时间 t 的向量场，由 CNF 模型学习得到。</li>
<li>\(div\) 是散度算子。</li>
</ul>
<p>这个方程表明，概率密度的变化率必须与其“流动”情况相互抵消，以保证总概率守恒。</p>
<h3 id="计算概率密度的步骤">计算概率密度的步骤</h3>
<p><strong>步骤 1： 瞬时变量的变化</strong></p>
<p>将连续性方程与流的轨迹方程 (\(\frac{d}{dt}\phi_t(x) = v_t(\phi_t(x))\)) 结合，可以得到以下瞬时变量的变化：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mi>t</mi></msub><mo stretchy="false">(</mo><msub><mi>ϕ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>v</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>t</mi></msub><mo stretchy="false">(</mo><msub><mi>ϕ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\frac{d}{dt}\log p_t(\phi_t(x)) + div(v_t(\phi_t(x)) = 0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span></p>
<p><strong>步骤 2：积分计算对数概率</strong></p>
<p>对上述方程在时间区间[0,1]上积分，得到：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>ϕ</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>ϕ</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><msubsup><mo>∫</mo><mn>0</mn><mn>1</mn></msubsup><mi>d</mi><mi>i</mi><mi>v</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>t</mi></msub><mo stretchy="false">(</mo><msub><mi>ϕ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\log p_1(\phi_1(x)) - \log p_0(\phi_0(x)) = -\int^1_0 div(v_t(\phi_t(x)))dt
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.476em;vertical-align:-0.9119em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.564em;"><span style="top:-1.7881em;margin-left:-0.4445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)))</span><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span></span></span></p>
<p><strong>步骤 3：求解常微分方程</strong></p>
<p>为了计算 \(\log p_1(x_1)\)，我们需要求解以下常微分方程 (ODE)：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>ϕ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>v</mi><mi>t</mi></msub><mo stretchy="false">(</mo><msub><mi>ϕ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>d</mi><mi>i</mi><mi>v</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>t</mi></msub><mo stretchy="false">(</mo><msub><mi>ϕ</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\frac{d}{dt}\begin{bmatrix}\phi_t(x)\cr f(t)\end{bmatrix} = \begin{bmatrix}v_t(\phi_t(x))\cr -div(v_t(\phi_t(x)))\end{bmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)))</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p>
<p>其中 \(f(t)\) 是一个辅助变量，用于记录 \(\log p_t(\phi_t(x))\) 的变化。初始条件为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>ϕ</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mn>0</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>c</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{bmatrix}\phi_0(x)\cr f(0)\end{bmatrix} = \begin{bmatrix}x_0\cr c\end{bmatrix} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p>
<p>其中 \(x_0\) 是初始分布 \(p_0(x) \)中的样本，\(c\) 是一个常数。</p>
<p><strong>步骤 4：计算最终概率</strong></p>
<p>求解上述 ODE 后，我们可以得到 \(f(1)\)。根据步骤 2 中的积分公式，我们可以得到：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo>+</mo><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>−</mo><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(1) = c + \log p_1(x_1) - \log p_0(x_0)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>因此，我们可以计算出 CNF 模型在数据点 \(x_1\) 的概率密度：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>e</mi><mi>x</mi><mi>p</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>c</mi><mo>+</mo><mi>log</mi><mo>⁡</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_1(x_1) = exp(f(1) - c + \log p_0(x_0))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span></span></p>
<h3 id="总结">总结</h3>
<p>通过利用连续性方程和流的轨迹方程，我们可以推导出计算 CNF 模型在任意数据点 x1 概率密度的方法。这个方法需要求解一个常微分方程，并利用初始条件和积分公式来计算最终的概率密度。</p>
]]></content>
      <categories>
        <category>Diffusion Model</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>人工智能</tag>
        <tag>扩散模型</tag>
      </tags>
  </entry>
  <entry>
    <title>连续性方程在流匹配中的理解</title>
    <url>/2024/10/28/%E8%BF%9E%E7%BB%AD%E6%80%A7%E6%96%B9%E7%A8%8B%E5%9C%A8%E6%B5%81%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<!-- <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> -->
<p>连续性方程是偏微分方程 (PDE)，它提供了一个必要且充分的条件，以确保向量场 \(v_t\) 生成概率路径 \(pt\)。 换句话说，它验证了给定的向量场是否确实生成了期望的概率密度演变。</p>
<p><strong>连续性方程：</strong></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><msub><mi>p</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>v</mi><mo stretchy="false">(</mo><msub><mi>p</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msub><mi>v</mi><mi>t</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\frac{d}{dt} p_t(x) + div(p_t(x)v_t(x)) = 0 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>其中：</p>
<ul>
<li>\(p_t(x)\) 是时间 \(t\) 的概率密度函数。</li>
<li>\(v_t(x)\) 是时间 \(t\) 的向量场。</li>
<li>\(div\) 是关于空间变量 \(x = (x^1, …, x^d)\) 的散度算子，即  \(div = \sum_{i=1}^d \frac{\partial}{\partial x^i}\) 。</li>
</ul>
<p><strong>连续性方程在流匹配中的作用：</strong></p>
<ul>
<li><strong>验证向量场：</strong> 连续性方程用于检验学习到的 CNF 模型的向量场 \(v_t\) 是否确实生成了目标概率路径 \(p_t(x)\)。</li>
<li><strong>证明定理：</strong> 在证明流匹配的相关定理时，连续性方程起着关键作用。例如，在定理 1 的证明中，通过验证边际概率路径 \(p_t\) 和边际向量场 \(u_t\) 满足连续性方程，可以证明 \(u_t\) 确实生成了 \(p_t\)。</li>
</ul>
<p><strong>计算 CNF 模型的概率：</strong></p>
<p>连续性方程与流动的轨迹方程 (\(\frac{d}{dt} \phi_t(x) = v_t(\phi_t(x))\)) 结合，可以推导出瞬时变量的变化，并最终得到计算 CNF 模型在任意数据点 \(x_1\) 概率的方法。</p>
<p><strong>总结:</strong></p>
<p>连续性方程在流匹配中扮演着重要的角色，它不仅用于验证向量场，还在理论证明和概率计算中发挥着关键作用。</p>
]]></content>
      <categories>
        <category>Diffusion Model</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>人工智能</tag>
        <tag>扩散模型</tag>
      </tags>
  </entry>
</search>
