<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>论文阅读二十二：有限数据微调语言模型实用指南 | Model The World</title><meta name="author" content="Serge Wang"><meta name="copyright" content="Serge Wang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="摘要 使用预训练大型语言模型（LLMs）已经称为自然语言处理（NLP）中的事实标准，尽管它们需要大量数据。受最近以有限数据训练LLM为重点的研究激增的启发，特别是在低资源领域和语言中，本文调查了最近的迁移学习方法，以优化数据稀缺的下游任务中的模型性能。我们首先解决初始化和持续的预训练策略，以更好地利用未知领域和语言的先验知识。然后，我们研究如何在微调和少样本学习过程中最大限度地利用有限的数据。最后">
<meta property="og:type" content="article">
<meta property="og:title" content="论文阅读二十二：有限数据微调语言模型实用指南">
<meta property="og:url" content="https://sergewang.github.io/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%9A%E6%9C%89%E9%99%90%E6%95%B0%E6%8D%AE%E5%BE%AE%E8%B0%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/">
<meta property="og:site_name" content="Model The World">
<meta property="og:description" content="摘要 使用预训练大型语言模型（LLMs）已经称为自然语言处理（NLP）中的事实标准，尽管它们需要大量数据。受最近以有限数据训练LLM为重点的研究激增的启发，特别是在低资源领域和语言中，本文调查了最近的迁移学习方法，以优化数据稀缺的下游任务中的模型性能。我们首先解决初始化和持续的预训练策略，以更好地利用未知领域和语言的先验知识。然后，我们研究如何在微调和少样本学习过程中最大限度地利用有限的数据。最后">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sergewang.github.io/images/finetune-methods.png">
<meta property="article:published_time" content="2024-11-16T02:21:36.000Z">
<meta property="article:modified_time" content="2024-11-16T07:53:26.821Z">
<meta property="article:author" content="Serge Wang">
<meta property="article:tag" content="论文阅读">
<meta property="article:tag" content="LLM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sergewang.github.io/images/finetune-methods.png"><link rel="shortcut icon" href="/img/newlogo.png"><link rel="canonical" href="https://sergewang.github.io/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%9A%E6%9C%89%E9%99%90%E6%95%B0%E6%8D%AE%E5%BE%AE%E8%B0%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="IDUolVgWkW_cmu1mtW5hsxrrIjQfCHvq5hOTOkXeVNE"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?9dcb7eb7a8a6225c2b1f242f3b0894bf";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-XERFYF0N5K"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-XERFYF0N5K')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-XERFYF0N5K', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '论文阅读二十二：有限数据微调语言模型实用指南',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-16 15:53:26'
}</script></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/newlogo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/finetune-methods.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/newlogo.png" alt="Logo"><span class="site-name">Model The World</span></a><a class="nav-page-title" href="/"><span class="site-name">论文阅读二十二：有限数据微调语言模型实用指南</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">论文阅读二十二：有限数据微调语言模型实用指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-16T02:21:36.000Z" title="发表于 2024-11-16 10:21:36">2024-11-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-16T07:53:26.821Z" title="更新于 2024-11-16 15:53:26">2024-11-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LLM/">LLM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="摘要">摘要</h2>
<p>使用预训练大型语言模型（LLMs）已经称为自然语言处理（NLP）中的事实标准，尽管它们需要大量数据。受最近以有限数据训练LLM为重点的研究激增的启发，特别是在低资源领域和语言中，本文调查了最近的迁移学习方法，以优化数据稀缺的下游任务中的模型性能。我们首先解决初始化和持续的预训练策略，以更好地利用未知领域和语言的先验知识。然后，我们研究如何在微调和少样本学习过程中最大限度地利用有限的数据。最后一节从特定任务的角度，回顾了适用于不同数据稀缺程度的模型和方法。我们的目标是为从业者提供实用的指导方针，以克服数据受限带来的挑战，同时突出未来研究的有前景的方向。<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2411.09539">论文地址</a></p>
<h2 id="引言">引言</h2>
<p>预训练语言模型（PLMs）正在改变NLP领域，显示出学习和建模来自复杂和多样化领域的自然语言数据底层分布的出色能力（Han等人，2021）。然而，他们的训练需要大量的数据和计算资源，这在许多现实世界场景中可能是令人望而却步的（Bai et al.，2024），尤其是对于英语以外的语言和专业领域，例如医学（Crema et al.，2023；Van Veen et al.，2021）、化学（Jablonka et al。，2019）。处理这一常见问题的主要方法依赖于迁移学习范式，该范式涉及对大量通用或混合领域数据进行自我监督的预训练阶段，然后对特定领域和任务的数据进行（可能是多个）领域自适应和微调或少次学习步骤。值得注意的是，这一过程的第二阶段也需要大量数据。数据稀缺会导致过拟合、泛化能力差和次优性能。在数据有限的情况下对PLM进行微调需要仔细选择预训练策略、域自适应和有效的参数优化，以通过有效利用模型已有的知识来避免灾难性遗忘，从而实现最佳性能（Kirkpatrick等人，2017；Ramasesh等人，2021）。本文通过探索迁移学习的最新进展，解决了在数据有限的情况下训练LLM的挑战，特别是对于低资源语言和专业领域（表1）。我们从Scopus、Web of Science、Google Scholar和ACL Anthology收集的2500多篇论文开始进行系统综述。它面向NLP的研究人员和从业者，概述了当前最先进的方法和在数据稀缺场景中优化模型性能的实用指南。我们研究了将LLM适应数据有限的特定任务和领域的过程，重点是（1）<strong>选择适当的（连续的）预训练方法</strong>，以便在手头的低资源场景中有效地利用先验知识（§3）；（2） <strong>在微调（§4）和少样本学习（§5）过程中最大限度地利用有限数据</strong>；（3） 讨论<strong>各种迁移学习策略的假设、益处和局限性</strong>，突出研究人员面临的开放挑战；以及（4）针对具体任务的观点，以克服不同程度的数据稀缺，为从业者提供指导（§6）。</p>
<p><img src="methods.png" alt=""></p>
<h2 id="相关工作">相关工作</h2>
<p>最近的工作探索了各种策略，以提高PLM在数据稀缺场景中的性能，重点关注特定的任务、语言或领域（Yazar等人，2023；Krasadakis等人，2024；Laparra等人，2021）。我们全面概述了用于在有限数据下微调PLM的迁移学习方法，涵盖了各种策略和用例。可以说，数据增强是应对数据稀缺的最基本技术之一（Feng等人，2021）。然而，由于多样性有限和质量下降，对于低资源语言的专业领域来说，单独的数据增强可能是不够的或不切实际的（Chen等人，2023a；Stylianou等人，2023）。因此，本文侧重于<strong>以模型为中心的互补方法</strong>，更好地利用了可用数据。Treviso等人（2023）使用更广泛的资源效率定义来调查高效的NLP方法，包括数据、时间、存储和能量。Hedderich等人（2021）专注于低资源、有监督的NLP，包括远程监督和预训练编码器模型。相比之下，我们的工作采用了更实用的视角，以计算负担得起的方式对预训练模型的数据高效适应进行了结构化的概述，同时也考虑了特定任务的方面。</p>
<h2 id="预训练">预训练</h2>
<p>预训练是 LLMs 的初始基础训练阶段，使它们能够以自我监督的方式发展强大的通用和特定领域语言理解能力。这是 LLMs 即使在有限的标注数据下也能应对各种下游任务的关键成功因素之一（Radford 等人，2018 年）。</p>
<p>第一步是<strong>选择一个合适的模型架构</strong>（见§6），这直接涉及一些预训练目标的选项。这种选择需要与下游任务保持一致，以获得更好的可转移性。解码器模型最适合文本生成任务，并使用因果语言建模（CLM）目标（Brown等人，2020），该目标涉及在给定先前标记的情况下预测序列中的下一个标记。相比之下，编码器模型专注于分类任务，并采用某种形式的掩码语言建模（MLM）目标（Devlin等人，2019），其中对随机的标记子集进行掩码，并对模型进行训练以预测原始标记。这个目标对于学习双向表征特别有用。一种改进的变体，即替换标记检测（RTD），通过使用小型生成器网络替换输入标记显示出更好的收敛性（Clark等人，2020）。相反，编码器-解码器模型在文本转换任务中表现出色，并通过掩码或去噪序列到序列（S2S）预训练将掩码扩展到标记序列（Song等人，2019；Lewis等人，2020）。</p>
<h3 id="持续预训练">持续预训练</h3>
<p>从头开始训练模型在数据和计算资源方面往往是一个不可逾越的挑战。幸运的是，有越来越多的预训练模型可用于各种任务、语言和领域。持续预训练是一种强大的技术，它涉及有限数量的训练步骤，具有预训练目标和没有标签的窗口或下游任务数据（Gururangan等人，2020）。目标是弥合预训练数据与目标领域和语言之间的差距，从而提高下游任务的性能（Imani等人，2023）。持续预训练是一种功能强大的技术，它涉及数量有限的训练步骤，包括预训练目标和无标签的非领域或下游任务数据（Gururangan 等人，2020 年）。其目的是缩小预训练数据与目标领域和语言之间的差距，从而在下游任务中取得更好的成绩（Imani 等人，2023 年）。如果原始模式和目标模式之间存在相当大的差异，它允许我们用以前看不见的术语和短语扩展模型词汇表（Gnehm等人，2022）。值得注意的是，通过后续预训练，可以以自我监督的方式高效地重复使用标注的微调数据。一般来说，这种模型适应容易发生<strong>灾难性遗忘</strong>（Kalajdzievski，2024），需要在训练长度、数据大小和模型大小之间保持谨慎的平衡，并从额外的正则化中受益（§4）。值得注意的技术包括<strong>学习率预热</strong>（McCloskey和Cohen，1989）和<strong>经验回放</strong>（de Masson d’Autume等人，2019）。</p>
<p>对于解码器模型，单次预训练的模型大小与数据量之间的关系已被广泛探索，结果表明，数据需求巨大，<strong>模型大小和数据的比例大致相等</strong>（Kaplan 等人，2020 年；Hoffmann 等人，2022 年）。然而，这些关系如何转移到持续的预训练仍然是一个具有挑战性的悬而未决的问题。在数据稀缺的情况下，Muennighoff等人（2023a）发现，训练解码器长达16个轮次仍然可以获得有意义的收益。Gnehm等人（2022）证实了编码器模型的这一点，表明<strong>在较小的领域内语料库上继续进行预训练可以从更长的训练时间中受益</strong>。除了对整个模型进行持续的预训练外，一种有效的替代方法是<strong>只训练模型参数的一个子集</strong>（§4.1）。这种方法可以更好地平衡模型容量和数据大小，并有助于在适应新任务和领域的同时保留先验知识（Liu等人，2022；Jukic和’Snajder，2023）。</p>
<p><strong>跨语言对齐</strong>。跨语言对齐模型可以增强其跨语言能力，并在多语言环境中实现更好的性能。最简单的方法在来自不同语言的非配对单语语料库上训练，并且已经为模型配备了显著的多语言和跨语言迁移能力（Conneau和Lample，2019；Pires等人，2019；Muennighoff等人，2023b）。特别是，类型学上不同的、遥远的语言和那些在训练前语料库中存在较少的语言从随后的自我监督训练中受益，可能会使用扩展的词汇来提高跨语言表现（Lauscher等人，2020；Blevins和Zettlemoyer，2022）。在高资源和低资源语言之间进行统一采样的持续MLM预训练可以提高低资源语言的性能，同时在高资源语言上保持性能（Imani等人，2023）。有趣的是，Alabi等人（2022）在调整具有数亿个参数的MLM目标的编码器模型时显示了多语言诅咒的影响（Conneau等人，2020）：**分别适应每种语言的模型比训练单个多语言模型得分更高。**即使是少量的并行数据（例如翻译）也为学习更好的跨语言表示开辟了广泛的可能性。翻译语言建模（TLM）目标预测连接句子对中的掩码标记，学习理解跨语言的上下文（Conneau和Lample，2019）。另一种选择是屏蔽源语言句子中的标记，并要求模型预测目标语言中的匹配句子（Wang等人，2023a）。</p>
<p><strong>领域自适应</strong>。将预训练模型适应专门的领域，可以确保它们能够有效地处理特定领域的任务，特别是当专门领域的语言和词汇与预训练语言有很大不同时（Gururangan等人，2020）。许多领域都有大量适用于领域的语言模型，例如生物医学（Luo et al.，2022；Bressem et al.，2024）、法律（Noguti et al.，2023）、金融（赵et al.，2021）和科学（Beltagy et al.，2019）。<strong>领域自适应在相对少量的精心选择的数据下效果良好</strong>（Gnehm等人，2022）。<strong>它可能比将有限的领域特定数据与一般数据结合，并从头开始的训练更有效</strong>（Türkmen等人，2023）。与仅对域内数据进行微调相比，它还对看不见的数据表现出更好的泛化能力（Bai等人，2021）。在没有足够未标记数据的低资源环境中，使用类似的域内语料库进行持续的预训练可以提高性能（Jantscher等人，2023），但<strong>数据的质量和相关性与其数量同样重要</strong>（Mahapatra等人，2022）。Lu等人（2023）表明，<strong>专注于领域特定词汇的RTD目标优于随机掩蔽</strong>。结合对抗性领判别别器可以进一步增强编码器和解码器模型的域自适应（Du等人，2020；Bellegarda，2023）。在参数有效方法的情况下（§4.1），对新引入的参数进行预训练可以进一步提高性能（Liu等人，2022；Jukic和Snajder´，2023）。对于跨域设置，将原始预训练数据与域内语料库相结合可以进一步提高鲁棒性（Diao等人，2023）。</p>
<h2 id="微调">微调</h2>
<p>在低资源场景中微调PLM会带来过拟合和不稳定优化等挑战，因为与巨大的模型容量相比，数据量有限，这阻碍了对未知示例的泛化。</p>
<p><strong>灾难性遗忘缓解</strong>。为了有效地用小数据微调更深层次的transformer模型，适当的优化和正则化技术至关重要（Kalajdzievski，2024）。Zhang等人（2021）探讨了训练长度和重新初始化较高层的不同数量对BERT微调的影响。Xu等人（2021a）提出了一种基于输入的权重缩放策略，以稳定训练并加速低数据深度模型的收敛。他们还实证表明，<strong>大批量对小数据集的泛化有负面影响</strong>。<strong>分层学习率衰减（LLRD）将更高的学习率应用于网络的更深层次</strong>，目的是从预训练的网络中保留更一般的信息，并在最后一层学习特定任务的信息（Howard和Ruder，2018）。正则化策略通过<strong>鼓励参数保持接近其预训练值来减轻灾难性遗忘</strong>。预训练权重衰减对所有参数施加约束（Wiese等人，2017），而Mixout（Lee等人，2019）用预训练权重随机替换模型的一些权重。SMART（Jiang等人，2020a）结合了平滑诱导对抗正则化，以增强对小扰动的鲁棒性，并结合了Bregman近点优化，以避免在信任区域外进行激进的参数更新。除了优化和正则化之外，结合外部知识也是非常有效的。Phang等人（2019）提出，在转向数据有限的目标任务之前，首先对更大的中间任务进行微调。</p>
<h3 id="参数高效训练">参数高效训练</h3>
<p>对PLM中的整个参数集（数百万或数十亿）进行微调是低效的，在低资源环境中可能不稳定（Dodge等人，2020）。参数高效微调（PEFT）方法仅更新一组减少的权重，避免了高昂的计算成本。它们在数据稀缺的情况下特别有用，因为它们减轻了与完全重新训练相关的灾难性遗忘的风险。此外，一些方法甚至<strong>设法仅用一小部分参数来匹配完全微调的性能</strong>（Hu等人，2021；Lester等人，2021，Liu等人，2022；Jukic和Snajder´，2023）。</p>
<p><strong>基于掩码的方法</strong> <strong>不添加额外的参数，只训练模型权重的一个子集（特定层、参数类型等），同时保持其余部分不变</strong>。早期的工作只是在编码器模型之上训练（额外的）最后一层（Devlin等人，2019）。BitFit（Ben Zaken等人，2022）调整了模型的偏差项，使其高效。另一项工作侧重于基于梯度信息的子网优化，要么在训练前选择一个固定的子网（Xu等人，2021b；Ansell等人，2022），要么使用多阶段优化策略在训练时自适应地选择它（Zhang等人，2022；Yu等人，2023）。基于掩码的方法高效且易于实施；然而，与添加新的可训练参数的其他PEFT方法相比，它们<strong>往往表现不佳</strong>（Liu等人，2022；Mao等人，2022）。</p>
<p><strong>适配器</strong> 是<strong>可训练的轻量级前馈模块，注入transformer层之间，而模型的其余部分是固定的</strong>（Houlsby等人，2019；Pfeiffer等人，2020）。顺序适配器是模型中的瓶颈，与其他PEFT方法相比，需要更宽的层和更多的参数来保持性能（Hu等人，2023b）。Compacter（Karimi Mahabadi等人，2021）通过利用<strong>低秩矩阵和参数共享</strong>缓解了这一问题。适配器减少了训练时间和内存消耗，但由于<strong>额外的模型深度，对推理时间产生了负面影响</strong>（Rücklé等人，2021年）。并行适配器（He等人，2021）和梯形边调谐（Sung等人，2022）通过<strong>将可学习模块与骨干模型并行结合</strong>来缓解这一问题。多个适配器也可以灵活组合，以模块化的方式处理复杂的任务（Pfeiffer等人，2021；Wang等人，2022；Chronopoulou等人，2023）。</p>
<p><strong>前缀调优</strong> 建立在上下文学习的基础上，但它 <strong>不是寻找离散的标记，而是优化连续嵌入，作为模型的特定任务上下文</strong>。具体而言，该方法<strong>将学习到的标记向量预先添加到每个transformer块中多头注意力层的输入键和值中</strong>，作为要关注的虚拟标记（Li和Liang，2021）。 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><msup><mi>A</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">IA^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> 引入学习向量来缩放注意力机制和前馈网络中的键和值，显示出性能的提高（与适配器相当），参数增加了一个数量级（Liu等人，2022）。提示调优（Lester等人，2021）通过<strong>将前缀限制在输入嵌入中</strong>进一步减少了参数的数量。这种方法在非常大的模型尺寸（数十亿个参数）下具有竞争力，并且收敛速度较慢（Mao等人，2022）。总体而言，前缀调优提供了一种灵活有效的方法来适应跨域和跨语言低资源场景中的模型（Tu et al.，2024；Goswami et al.，2023；赵et al.，2022），<strong>其参数比适配器或重参数化方法少得多</strong>。</p>
<p><strong>重新参数化方法</strong> 的灵感来自<strong>LLM参数位于低维流形</strong>上的观察。内在SAID（Aghajanyan等人，2021）研究了内在维度，并将<strong>加性权重矩阵投影到这个子空间中</strong>。同样，LoRA（Hu等人，2021）<strong>将权重矩阵分解为两个低秩矩阵的乘积，在不影响太多性能的情况下显著减少了参数数量</strong>。KronA（Edalati等人，2022）取代了<strong>Kronecker分解</strong>，并显示出更好的下游性能。重新参数化方法最适用于<strong>大型权重矩阵，因此也适用于具有中等或更多数据量的大型模型</strong>（Van Veen等人，2023）。</p>
<p><strong>混合方法</strong> 结合了多种PEFT方法，以利用其各自的优势。UniPELT（Mao等人，2022）使用门控机制动态激活适配器、前缀调优和LoRA，以优化给定任务和数据设置的性能。Chen等人（2022a）引入了设计空间来参数化层分组、可训练参数分配和PEFT策略选择。</p>
<h3 id="嵌入学习">嵌入学习</h3>
<p>嵌入向量是NLP任务中输入标记的数值表示。它们对于LLM在下游任务中的成功至关重要，使模型能够捕获输入文本的语义信息，包括特定语言、领域和任务的细微差别（Collobert等人，2011）。然而，语言模型仅限于由固定粒度的标记化阶段产生的预定义词汇表。<strong>选择粒度意味着在时间和空间复杂性方面进行权衡。<strong>字级粒度更具表现力，但需要更大的词汇量和更多的内存，而字符或字节级粒度更节省空间，但表现力较低，会产生很长的序列（Bojanowski等人，2017；Ruder等人，2023）。作为折衷方案，大多数模型使用</strong>子字级粒度</strong>（subword），这通常是两者之间的良好平衡（Kudo和Richardson，2018）。最佳粒度取决于任务和语言。<strong>固定的词汇表对小的文本扰动很敏感，并限制了对新任务和领域的泛化</strong>。 为了解决这个问题，Sun等人（2023）提出训练一个浅层transformer从字符中学习单词表示，使其对拼写错误和域转换具有鲁棒性。最近的工作使用冻结的transformer架构训练标签机嵌入，以解决预训练域和目标域与语言词汇之间的差异（Artetxe等人，2020；Hung等人，2023）。<strong>这种方法比完全微调更有效，可以作为中间训练步骤</strong>。或者，Nag等人（2023）<strong>根据标记嵌入的熵识别易受碎片化影响的单词，并用这些单词的新嵌入来扩充词汇量</strong>。增强跨语言迁移的另一种方法是<strong>使用并行数据或种子字典将不同语言的嵌入映射到共享空间中</strong>（Mikolov等人，2013；Lalrempuii和Soni，2023）。以这种方式利用高资源语言嵌入对低资源下游任务非常有益（Minixhofer等人，2022；Deshpande等人，2022年；Deb等人，2023年）。其他研究通过配对数据上的对齐训练目标建立了<strong>隐式映射</strong>（Cao等人，2019；Saadi等人，2022）。</p>
<h3 id="对比学习和对抗学习">对比学习和对抗学习</h3>
<p>对比和对抗学习方法从语言和领域之间的<strong>差异和相似性</strong>中提取有意义的信息，增强模型的一致性和适应性。</p>
<p><strong>对比学习</strong>（CL）旨在通过<strong>将语义上紧密的配对拉到一起并推开无关的样本</strong>来学习有效的表征（Chen等人，2020b）。它通常需要并行数据，并且可以在多个粒度级别上发生：句子（Chi等人，2021a）和单词（Chi等人，2021b；Chen等人，2023b）。对齐与跨不同语言和模型的跨语言迁移显著相关（Gaschi等人，2023），仅在源语言中使用标记示例在下游任务中取得了显著的性能（Hu等人，2023a；Kowsher等人，2023年）。许多其他工作强调了对比跨语言性与衔接等PEFT方法的协同作用（Liu等人，2023b，A；Ahmat等人，2023）。除了跨语言对齐外，CL在下游任务级别也有利于更好地利用数据。对于文本相似性任务，它可以通过使用数据增强技术生成正对来充当无监督目标（Gao等人，2021b；Yan等人，2021）。通过<strong>锚定到类的文本描述（Pauli等人，2023）或重新表述为问答（QA）任务</strong>（Chen等人，2023c），可以很容易地为二元分类任务（如机器生成的文本检测（Liu等人，2023e））和其他分类任务（如情绪分析或命名实体识别（NER））创建CL对。</p>
<p><strong>对抗学习</strong> 是指<strong>同时训练两个目标相互矛盾的模型，引导彼此取得更好的成绩</strong>（Goodfellow等人，2014）。对抗训练可以<strong>在没有任何配对数据的情况下</strong>帮助弥合预训练和目标领域或语言之间的差距。<strong>关键机制是训练一个需要被模型欺骗的语言或领域判别器，迫使它学习领域不变（Du等人，2020；Grießhaber等人，2020）或语言无关（Lange等人，2020，Huang等人，2023c）的鲁棒表示</strong>。这也可以与PEFT方法相结合，如适配器（Ngo Trung等人，2021）或特定于或独立于领域的学习前缀（赵等人，2022）。</p>
<h3 id="有限监督">有限监督</h3>
<p>在低资源场景中，<strong>半监督、无监督和主动学习方法</strong>可以成功地利用未标记的数据来提高模型的泛化能力和鲁棒性。</p>
<p><strong>半监督学习</strong> （SSL）在训练过程中利用标记和未标记的数据（Chapelle等人，2009）。一种常见的方法是自我训练，即<strong>在有标签数据上训练模型，然后将其在无标签数据上的预测视为伪标签</strong>，以进行额外训练，主要基于模型置信度 (Schick andSchütze，2021a；Wang 等人，2023b；Lalrempuiiand Soni，2023) 或熵 (Chen 等人，2020a)。然而，为了避免确认偏差，<strong>适当的正则化是必不可少的</strong>（Toivanen等人，2022）。与标准方法不同，一<strong>致性正则化促进了对扰动输入的稳定预测</strong>（Sohn等人，2020；Xie等人，2020，Li等人，2019）。另一种常见的SSL方法是联合训练，其中<strong>多个模块在输入数据的不同视图上进行训练，并相互预测伪标签，或者需要就最终预测达成一致</strong>（Clark等人，2018；Bhattacharjee等人，2020）。SSL在迁移学习方法中特别有用，语言模型可以从预先训练的知识中获益，并为目标任务生成更好的伪标签。</p>
<p><strong>无监督方法</strong> 仅使用未标记的数据训练模型，这使得它们在标记数据稀缺或不可用的情况下特别有用。PLM成功的最突出的例子和关键因素是其<strong>自我监督的预训练目标</strong>（第3节），该目标也可用于适配器等PEFT模块的预训练（Diao等人，2023）。另一方面，在微调过程中，无监督方法利用了某种形式的一致性条件。除了涉及扰动输入的<strong>一致性正则化</strong>（§4.4）外，还可以使用<strong>循环一致性</strong>来描述不同模态之间的关系（Zhu等人，2017）。需要未经处理的数据来学习潜在不同域（Karisani，2022；Buehler，2023）、语言（Lample等人，2018；Ren等人，2019）甚至文本样式（Jalota等人，2023）之间的双向关系。在实践中，无监督目标需要大量未标记的数据来学习数据分布的有意义表示。因此，他们经常与直接监督相结合，以提高性能。</p>
<p><strong>主动学习</strong>（AL）技术侧重于<strong>选择信息量最大的数据点，以最大限度地提高有限训练数据的有效性</strong>。这种方法假设了一种特殊的情况，即数据未标记，注释预算受限，这种情况在现实世界的应用中很常见（Ren等人，2021）。通过置信度得分、熵、蒙特卡洛丢弃和困惑度等指标来表示<strong>模型的高度不确定性</strong>是最突出的数据采样标准（Lewis andGale，1994；Gal and Ghahramani，2016；Houlsbyet al.，2011；Yuan et al.，2020；Muradoglu andHulden，2022；Jantscher et al.，2023）。这些可以与基于多样性的采样策略相结合，<strong>基于数据分布相似性或梯度方差</strong>，以确保平衡的数据表示并减少异常值（Sener和Savarese，2018；Gissin和Shalev-Shwartz，2018；Ash等人，2019；Ein-Dor等人，2020；Margatina等人，2021；Karamcheti等人，2021，François和Gay，2023）。</p>
<p>使用AL训练模型是一个迭代过程，其中根据逐步细化的模型选择一小批未标记的样本进行注释。在回合之间<strong>重新初始化模型比用新数据增量更新模型更稳定</strong>，特别是对于代表性不足的类别（Lemmens和Daelemans，2023）。对于冷启动问题，随机抽样的替代方法是使用自监督目标作为不确定性的替代品（Yuan等人，2020）。将AL与适配器和UniPELT等PEFT技术集成在一起，在提高低资源任务的性能方面取得了可喜的成果（Jukic和Snajder，2023）。总体而言，AL策略允许模型从有限的数据中高效学习，减少注释负担，并根据任务复杂性进行调整。</p>
<h2 id="少样本学习">少样本学习</h2>
<p>在少样本学习中，模型只给出了新任务的有限示例，必须推广到看不见的数据。本节涵盖了对目标数据进行微调和不进行微调的方法。</p>
<h3 id="上下文学习">上下文学习</h3>
<p>随着能够从大量文本数据集中隐式吸收大量任务的大型解码器模型的兴起，上下文学习（ICL）或提示已成为利用这些模型泛化能力的流行方法（Liu等人，2023c）。在CLM预训练之后，会话模型通常通过强化学习与用户意图保持一致，以提高有用性、准确性和安全性（Ouyang等人，2022）。这使得模型只需几个例子就能处理新任务，而无需昂贵的基于梯度的训练（Petroni等人，2019；Radford等人，2019年；Brown等人，2020年）。此外，ICL甚至可以在非常低的样本设置中优于微调（Gao等人，2021a；Jiang等人，2020b；Garcia等人，2023），但性能会随着提示质量的变化而显著变化（Liu等人，2023d）。</p>
<p>离散提示具有直观和可解释的优点，但大多需要手工制作，这使得它在转移到新模型和任务时效率低下（Sanh等人，2022）。合适的填充模板和提示库可以减轻这种负担（Shin等人，2020；Bach等人，2022；Bodonhelyi等人，2024），检索器模块提供了一种自动选择相关示例的方法，减轻了人工劳动并提高了性能（Li等人，2023a）。方便的是，<strong>任何自然语言理解任务都可以被表述为文本生成任务</strong>（Liu等人，2023c），并且有许多复杂的提示技术可以提高少样本学习性能（Xie等人，2022；Liu等人，2033c），如思维链（Wei等人，2022）。 ICL的一些缺点包括在具有大上下文窗口的非常大的生成模型中最有效，这反过来又导致推理过程中计算成本的急剧增加（Reynolds和McDonnell，2021；Pawar等人，2024）。</p>
<h3 id="模式利用训练">模式利用训练</h3>
<p>模式利用训练（PET）或基于提示的微调以完形填空格式制定分类任务（Taylor，1953），使模型能够预测具有MLM目标的目标，从而协调预训练和微调（Schick和Schütze，2021a，b）。这种方法特别适用于低资源语言和专业领域中的少数样本分类（Ullah等人，2023；Song等人，2024；Lu等人，2023），但需要针对任务和数据量身定制的手工模式和描述器。模式模板将输入转换为完形填空风格的提示，而描述器将标签映射到词汇表中的目标标记序列。在跨语言场景中，将PET与一致性损失相结合有助于更好地学习跨语言对应（Qi等人，2022）。为了进行推理，该方法使用了一种代价高昂的自回归解码方案，用于由多个标记组成的言语化目标。许多研究侧重于通过计算<strong>与目标嵌入平均值的相似性</strong>（Hardalov等人，2022）、<strong>使用原型最近邻解码</strong>（Karimi Mahabadi等人，2022年）或<strong>进化描述器搜索算法</strong>（Ling等人，2023年）来优化推理效率。Karimi Mahabadi等人（2022）还分别用学习到的标签嵌入和任务特定的适配器取代了手工制作的描述器和模式，从而提高了性能。</p>
<h3 id="多任务学习">多任务学习</h3>
<p>多任务微调已成为改善具有数十亿参数的大型生成模型的零样本任务泛化的标准配方（Ruder，2017；Aribandi等人，2021；Wei等人，2021）。这些模型是在一组庞大而多样化的相关下游任务上进行指令调优的，这使得它们成为非常强大的基线，即使在有限的数据或计算资源不允许针对特定用例进行微调的情况下，也可以与之进行比较（Liu等人，2019；Sanh等人，2022；Van Veen等人，2023）。多任务模型通常使用共享层来学习健壮的共同特征，同时使用任务特定层来捕捉每个任务的独特方面（Caruana，1997；Ruder，2017）。在此基础上，混合专家（MoE）模型通过小子网络路由计算，以在任务之间共享表示并提高整体性能（Shazeer等人，2017；Fedus等人，2022；Zoph，2022；Baniata和Kang，2024）。</p>
<h3 id="元学习">元学习</h3>
<p>人类发展理论的启发，元学习强调从过去的经验中学习先验知识，以促进有效的下游适应。在少样本学习的背景下，基于度量的方法在潜在空间中学习相似性得分，以比较新的和看到的样本。类原型在度量空间中编码类特定信息（Snell等人，2017；Wen等人，2021）。更好地构建嵌入空间并包括专家知识的其他选项包括结合PET的实例和类特定CL（Wu等人，2024），或锚定到具有三重态损失的类描述（Pauli等人，2023）。在推理过程中，使用成对比较或其他非参数学习算法，如kNearest Neighbors（François和Gay，2023）来预测新示例的类别。这些模型的有效性依赖于具有代表性的类别示例。另一个突出的方向是学习一组合适的初始化参数，这些参数可以在几个优化步骤中进行微调，以实现对以前看不到的任务的快速适应（Finn等人，2017）。基于优化的技术将元学习视为一个两级优化问题，一个特定于任务的内部循环和一个与任务无关的外部循环。来自内环支持集的更新权重用于在查询集上提供梯度，以更新外环中的模型参数（Bansal等人，2020；Li等人，2022；Huang等人，2023b；Chien等人，2023）。在此之后，目标任务的射击更新很少。这两种策略适用于具有编码器模型的分类任务。</p>
<h2 id="数据高效的NLP技术">数据高效的NLP技术</h2>
<p>本节概述了数据有限的不同NLP任务的最有效方法（表2）。</p>
<p><img src="approaches.png" alt=""></p>
<p><strong>模型选择</strong>。选择正确的预训练模型对于在目标任务、领域和语言中实现最佳性能至关重要。最重要的因素包括<strong>模型架构、参数数量以及预训练数据的大小、类型和质量</strong>（Alabi等人，2020）。<strong>大型生成模型可以通过适当的任务形式应用于所有NLP任务</strong>（Liu等人，2023c）。然而，对于NLU任务，<strong>只有几百万个参数的双向编码器模型可以匹配或优于具有数十亿个参数的解码器模型</strong>（Schick和Schütze，2021a；García-Díaz等人，2023）。同时，解码器组件对于文本生成任务是必不可少的，并且需要比编码模型多1-2个数量级的参数（Brown等人，2020）。从NLU任务可以追溯到分类这一事实中可以明显看出，这比从词汇表中的数万个标记预测序列中的下一个标记的文本生成任务要简单得多（Radford等人，2018）。</p>
<p>对于低资源语言或特定领域，具有70B或更多参数的较大模型，在不同的多语言或特定领域数据上进行预训练，可以提供强大的零次或少次上下文学习能力（Brown等人，2020；Armengol Estapé等人，2022；Lin等人，2022）。相比之下，对于有限数据的微调，具有8-11B参数的生成模型可以与更大的模型的性能相匹配。同时效率要高得多（Liu等人，2022；Muennighoff等人，2023b）。<strong>对于低资源分类任务，较大的编码器模型始终优于较小的编码器模型</strong>（Schick和Schütze，2021a；Karimi Mahabadi等人，2022；Kowsher等人，2023）。</p>
<p><strong>处理有限的数据</strong>。在资源非常低的情况下，任何NLP任务的最快选择都是上下文学习（§5.1），它也不需要任何基于梯度的训练，通常是一个竞争性的基线（Liu等人，2022；Chen等人，2022b）。对于少样本分类任务，具有适配器的PET（§5.2）在利用预先训练的知识方面非常有效（Qi等人，2022；Ullah等人，2023；Karimi Mahabadi等人，2022年；赵等人，2022）。在1K注释示例以下，额外注释或使用来自高资源语言或通用领域的类似任务数据集进行中间微调步骤可以大大提高对目标任务的泛化能力（Chen等人，2023c；Moscato等人，2023；Laurer等人，2024）。超过这个阈值，持续的预训练（§3.1）变得越来越有效，随着可用的未标记数据量的增加而扩展（Bai等人，2021；Mahapatra等人，2022；Goswami等人，2023）。与使用数十亿个标记的大规模编码器预训练相比，仅使用10万个标记的任务、域或语言数据的持续预训练可以使下游任务受益，特别是对于引入的PEFT方法的权重（Gururangan等人，2020；Gnehm等人，2022；Jukic和’Snajder，2023）。除了训练前数据的数量外，数据的质量也是一个重要因素（Mahapatra等人，2022；Buonocore等人，2023）。在数据有限的情况下，通过适当的正则化来减轻灾难性遗忘至关重要（§4）。</p>
<p>PEFT方法（§4.1）在使大型预训练模型适应数据有限的新任务，同时保持泛化能力方面特别有效（表2）。适配器、前缀和在某些情况下的参数掩码往往更适合较少的数据，而LoRA和完全微调随着标记数据量的增加而表现更好（Tai等人，2020；Li和Liang，2021；Xu等人，2021a；Mao等人，2022；Buonocore等人，2023；Wu等人，2023，Ding等人，2023和Jablonka等人，2024）。Prompt-tuning在低资源设置中也可以优于完全微调，但它通常比前缀调优收敛较慢，它在更大的模型上效果最好（Goswami等人，2023；Choi和Lee，2023）。作为补充选项，CL提高了下游任务（Gao等人，2021b；Yan等人，2021）和跨语言（Hu等人，2023a；Kowsher等人，2023）的表示质量，主动学习最大限度地提高了数据效用（Yuan等人，2020；Lemmens和Daelemans，2023；Jantscher等人，2023；半监督学习进一步提高了性能和鲁棒性（Clark等人，2018；Wang等人，2023b；Shi等人，2023。）。</p>
<h2 id="结论">结论</h2>
<p>这项调查解决了在数据稀缺的情况下应用LM的挑战。具体来说，我们首先系统地概述了在稀缺数据下进行有效和高效的后续预训练和下游微调时需要考虑的重要方面的方法，并强调了其优点和局限性。</p>
<p>我们将NLP任务分为五组，并总结了合适的预训练模型、适应和微调方法，以及数据可用性不同维度的辅助选项。我们的研究结果表明，选择更大的模型，并将合适的参数高效方法与适当的正则化技术和互补的训练选项相结合，可以显著提高低资源场景中的性能。在固定程度的数据稀缺性下，<strong>在模型适应过程中防止灾难性遗忘的理论和实验工作仍然有限</strong>。此外，在专业领域和资源贫乏的语言交叉处，对不同任务中更广泛的方法进行基准测试在很大程度上被忽视了，这也强调了需要额外的公共数据集和标准化的评估框架。我们还鼓励社区研究不同方法的组合，以利用它们的互补优势。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://SergeWang.github.io">Serge Wang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://sergewang.github.io/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%9A%E6%9C%89%E9%99%90%E6%95%B0%E6%8D%AE%E5%BE%AE%E8%B0%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/">https://sergewang.github.io/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%9A%E6%9C%89%E9%99%90%E6%95%B0%E6%8D%AE%E5%BE%AE%E8%B0%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://SergeWang.github.io" target="_blank">Model The World</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a><a class="post-meta__tags" href="/tags/LLM/">LLM</a></div><div class="post-share"><div class="social-share" data-image="/images/finetune-methods.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%9B%B6%E6%A0%B7%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%B5%8B%E8%AF%95%E7%9A%84LLM%E5%B9%BB%E8%A7%89%E6%8E%A8%E7%90%86/" title="论文阅读二十三：基于零样本知识测试的LLM幻觉推理"><img class="cover" src="/images/hallucination-reasoning.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">论文阅读二十三：基于零样本知识测试的LLM幻觉推理</div></div><div class="info-2"><div class="info-item-1">摘要 LLM幻觉，LLM偶尔会产生不忠实的文本，对其实际应用构成了重大挑战。大多数现有的检测方法依赖于外部知识、LLM微调或幻觉标记的数据集，并且它们不能区分不同类型的幻觉，而幻觉对于提高检测性能至关重要。我们引入了一个新的任务，幻觉推理，它将LLM生成的文本分为三类：对齐、未对齐和伪造。我们新颖的零样本方法评估LLM是否对给定的提示和文本有足够的知识。我们在新数据集上进行的实验证明了我们的方法在幻觉推理中的有效性，并强调了它对提高检测性能的重要性。...</div></div></div></a><a class="pagination-related" href="/2024/11/14/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%9A%E9%80%9A%E8%BF%87%E8%BF%91%E4%BC%BC%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3%E5%85%8B%E6%9C%8D%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E7%BB%B4%E6%95%B0%E8%AF%85%E5%92%92/" title="论文阅读二十一：通过近似因子分解克服强化学习中的维数诅咒"><img class="cover" src="/images/approximation-factorization.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">论文阅读二十一：通过近似因子分解克服强化学习中的维数诅咒</div></div><div class="info-2"><div class="info-item-1">摘要 众所周知，强化学习（RL）算法存在维数灾难，这是指大规模问题往往导致样本复杂度呈指数级增长。常用解决方案是使用深度神经网络进行函数近似。然而，这种方式通常缺少理论保障。为了理论性地解决维数诅咒，我们观察到，许多真实世界问题显示出特定任务的结构，当适当利用时，可以改进RL的样本效率。基于这种见解，我们提出通过将原始马尔可夫决策过程（MDP）近似分解到较小的、独立演化的MDPs来解决维数诅咒。这种因子分解使得在基于模型和无模型的环境中开发样本高效的RL算法成为可能，后者涉及方差减少的Q学习变体。我们为这两种提出的算法提供了改进的样本复杂度保证。值得注意的是，通过MDP的近似因式分解利用模型结构，样本复杂性对状态动作空间大小的依赖性可以呈指数级降低。从数值上讲，我们通过在合成MDP任务和配备风电场的储能控制问题上的实验证明了我们提出的方法的实用性。论文地址 引言 近年来，强化学习已经成为未知环境中解决序列决策问题的流行框架，应用在不同领域，如机器人（Kober等，2013）、运输（Haydari &amp;...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/03/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B8%83%EF%BC%9ALLAMAFACTORY%EF%BC%9A100%E5%A4%9A%E7%A7%8D%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%9F%E4%B8%80%E9%AB%98%E6%95%88%E5%BE%AE%E8%B0%83/" title="论文阅读七：LLaMA-Factory：100多种语言模型的统一高效微调"><img class="cover" src="/2024/11/03/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B8%83%EF%BC%9ALLAMAFACTORY%EF%BC%9A100%E5%A4%9A%E7%A7%8D%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%9F%E4%B8%80%E9%AB%98%E6%95%88%E5%BE%AE%E8%B0%83/architecture.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-03</div><div class="info-item-2">论文阅读七：LLaMA-Factory：100多种语言模型的统一高效微调</div></div><div class="info-2"><div class="info-item-1"> 摘要 高效的微调对于使大型语言模型（LLM）适应下游任务至关重要。然而，在不同的模型上实现这些方法需要付出巨大的努力。我们介绍LLAMAFACTORY，这是一个整合了一套尖端高效训练方法的统一框架。它提供了一种解决方案，可以灵活地定制100多个LLM的微调，而无需通过内置的web UI LLAMABOARD进行编码。我们实证验证了我们的框架在语言建模和文本生成任务上的效率和有效性。它已发布于 https://github.com/hiyouga/LLaMA-Factory ，并获得了25000多颗星和3000个fork。 引言 大型语言模型（LLM）（赵等人，2023）具有显著的推理能力，并赋予了广泛的应用，如问答（Jiang等人，2023b）、机器翻译（Wang等人，2023c；Jiao等人，2023a）和信息提取（Jiao等人（2023b））。随后，大量LLM被开发出来，并可通过开源社区访问。例如，Hugging...</div></div></div></a><a class="pagination-related" href="/2024/11/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B9%9D%EF%BC%9AOPENCODER%EF%BC%9A%E9%A1%B6%E7%BA%A7%E4%BB%A3%E7%A0%81LLM%E7%9A%84%E5%BC%80%E6%94%BE%E6%89%8B%E5%86%8C/" title="论文阅读九：OPENCODER：顶级代码LLM的开放手册"><img class="cover" src="/images/opencoder.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-10</div><div class="info-item-2">论文阅读九：OPENCODER：顶级代码LLM的开放手册</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%9B%B6%E6%A0%B7%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%B5%8B%E8%AF%95%E7%9A%84LLM%E5%B9%BB%E8%A7%89%E6%8E%A8%E7%90%86/" title="论文阅读二十三：基于零样本知识测试的LLM幻觉推理"><img class="cover" src="/images/hallucination-reasoning.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-16</div><div class="info-item-2">论文阅读二十三：基于零样本知识测试的LLM幻觉推理</div></div><div class="info-2"><div class="info-item-1">摘要 LLM幻觉，LLM偶尔会产生不忠实的文本，对其实际应用构成了重大挑战。大多数现有的检测方法依赖于外部知识、LLM微调或幻觉标记的数据集，并且它们不能区分不同类型的幻觉，而幻觉对于提高检测性能至关重要。我们引入了一个新的任务，幻觉推理，它将LLM生成的文本分为三类：对齐、未对齐和伪造。我们新颖的零样本方法评估LLM是否对给定的提示和文本有足够的知识。我们在新数据集上进行的实验证明了我们的方法在幻觉推理中的有效性，并强调了它对提高检测性能的重要性。...</div></div></div></a><a class="pagination-related" href="/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%9ASqueezed%20Attention%EF%BC%9A%E5%8A%A0%E9%80%9F%E9%95%BF%E4%B8%8A%E4%B8%8B%E6%96%87%E9%95%BF%E5%BA%A6LLM%E6%8E%A8%E7%90%86/" title="论文阅读二十四：Squeezed Attention：加速长上下文长度LLM推理"><img class="cover" src="/images/squeeze-attention.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-16</div><div class="info-item-2">论文阅读二十四：Squeezed Attention：加速长上下文长度LLM推理</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2024/11/14/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%EF%BC%9A%E4%BC%98%E5%8C%96%E7%BC%A9%E6%94%BELLM%E6%B5%8B%E8%AF%95%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97%E6%AF%94%E7%BC%A9%E6%94%BE%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E6%9B%B4%E6%9C%89%E6%95%88/" title="论文阅读二十：优化缩放LLM测试时间计算比缩放模型参数更有效"><img class="cover" src="/images/test-time-inference.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-14</div><div class="info-item-2">论文阅读二十：优化缩放LLM测试时间计算比缩放模型参数更有效</div></div><div class="info-2"><div class="info-item-1">使LLM能够通过使用更多的测试时间计算来提高其输出，是构建可以在开放式自然语言上运行的一般自我改进代理的关键一步。本文研究了LLM中推理时间计算的缩放，重点回答了以下问题：如果允许LLM使用固定但非微不足道的推理时间计算，那么它在具有挑战性的提示下能提高多少性能？回答这个问题不仅对LLM的可实现性能有影响，而且对LLM预训练的未来以及如何权衡推理时间和预训练计算也有影响。尽管它很重要，但很少有研究试图了解各种测试时间推理方法的缩放行为。此外，目前的工作在很大程度上为其中一些策略提供了负面结果。在这项工作中，我们分析了两种主要的机制来扩展测试时间计算：（1）针对密集的、基于过程的验证者奖励模型进行搜索；以及（2）在测试时给出提示的情况下自适应地更新模型在响应上的分布。我们发现，在这两种情况下，缩放测试时间计算的不同方法的有效性因提示的难度而异。这一观察结果促使应用...</div></div></div></a><a class="pagination-related" href="/2024/11/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%8D%81%E4%B8%80%EF%BC%9A%E7%A9%BF%E9%92%88%E5%BC%95%E7%BA%BF%EF%BC%9ALLMs%E8%83%BD%E5%90%A6%E7%A9%BF%E8%BF%87%E8%BF%91%E7%99%BE%E4%B8%87%E8%A7%84%E6%A8%A1%E7%9A%84%E5%B9%B2%E8%8D%89%E5%A0%86%EF%BC%9F/" title="论文阅读十一：穿针引线：LLMs能否穿过近百万规模的干草堆？"><img class="cover" src="/images/needlethreading.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-10</div><div class="info-item-2">论文阅读十一：穿针引线：LLMs能否穿过近百万规模的干草堆？</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/newlogo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Serge Wang</div><div class="author-info-description">今日事，今日毕</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SergeWang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SergeWang" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sergew027@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">相关工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E8%AE%AD%E7%BB%83"><span class="toc-number">4.</span> <span class="toc-text">预训练</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E7%BB%AD%E9%A2%84%E8%AE%AD%E7%BB%83"><span class="toc-number">4.1.</span> <span class="toc-text">持续预训练</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E8%B0%83"><span class="toc-number">5.</span> <span class="toc-text">微调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%AB%98%E6%95%88%E8%AE%AD%E7%BB%83"><span class="toc-number">5.1.</span> <span class="toc-text">参数高效训练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%AD%A6%E4%B9%A0"><span class="toc-number">5.2.</span> <span class="toc-text">嵌入学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%AF%B9%E6%8A%97%E5%AD%A6%E4%B9%A0"><span class="toc-number">5.3.</span> <span class="toc-text">对比学习和对抗学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%9B%91%E7%9D%A3"><span class="toc-number">5.4.</span> <span class="toc-text">有限监督</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%91%E6%A0%B7%E6%9C%AC%E5%AD%A6%E4%B9%A0"><span class="toc-number">6.</span> <span class="toc-text">少样本学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AD%A6%E4%B9%A0"><span class="toc-number">6.1.</span> <span class="toc-text">上下文学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%A9%E7%94%A8%E8%AE%AD%E7%BB%83"><span class="toc-number">6.2.</span> <span class="toc-text">模式利用训练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%AD%A6%E4%B9%A0"><span class="toc-number">6.3.</span> <span class="toc-text">多任务学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E5%AD%A6%E4%B9%A0"><span class="toc-number">6.4.</span> <span class="toc-text">元学习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%AB%98%E6%95%88%E7%9A%84NLP%E6%8A%80%E6%9C%AF"><span class="toc-number">7.</span> <span class="toc-text">数据高效的NLP技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">8.</span> <span class="toc-text">结论</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/20/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%9ASPLATFORMER%EF%BC%9A%E7%94%A8%E4%BA%8E%E7%A8%B3%E5%81%A53D%E9%AB%98%E6%96%AF%E6%BA%85%E5%B0%84%E7%9A%84%E7%82%B9Transformer/" title="论文阅读三十三：SPLATFORMER：用于稳健3D高斯溅射的点Transformer"><img src="/images/GSAM.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读三十三：SPLATFORMER：用于稳健3D高斯溅射的点Transformer"/></a><div class="content"><a class="title" href="/2024/11/20/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%9ASPLATFORMER%EF%BC%9A%E7%94%A8%E4%BA%8E%E7%A8%B3%E5%81%A53D%E9%AB%98%E6%96%AF%E6%BA%85%E5%B0%84%E7%9A%84%E7%82%B9Transformer/" title="论文阅读三十三：SPLATFORMER：用于稳健3D高斯溅射的点Transformer">论文阅读三十三：SPLATFORMER：用于稳健3D高斯溅射的点Transformer</a><time datetime="2024-11-20T09:18:03.000Z" title="发表于 2024-11-20 17:18:03">2024-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/18/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%9A%E5%B9%BF%E4%B9%89SAM%EF%BC%9A%E5%8F%AF%E5%8F%98%E8%BE%93%E5%85%A5%E5%9B%BE%E5%83%8F%E5%B0%BA%E5%AF%B8%E7%9A%84SAM%E7%9A%84%E9%AB%98%E6%95%88%E5%BE%AE%E8%B0%83/" title="论文阅读三十二：广义SAM：可变输入图像尺寸的SAM的高效微调"><img src="/images/GSAM.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读三十二：广义SAM：可变输入图像尺寸的SAM的高效微调"/></a><div class="content"><a class="title" href="/2024/11/18/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%9A%E5%B9%BF%E4%B9%89SAM%EF%BC%9A%E5%8F%AF%E5%8F%98%E8%BE%93%E5%85%A5%E5%9B%BE%E5%83%8F%E5%B0%BA%E5%AF%B8%E7%9A%84SAM%E7%9A%84%E9%AB%98%E6%95%88%E5%BE%AE%E8%B0%83/" title="论文阅读三十二：广义SAM：可变输入图像尺寸的SAM的高效微调">论文阅读三十二：广义SAM：可变输入图像尺寸的SAM的高效微调</a><time datetime="2024-11-18T11:33:03.000Z" title="发表于 2024-11-18 19:33:03">2024-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/18/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B8%89%E5%8D%81%E4%B8%80%EF%BC%9A3D%E9%AB%98%E6%96%AF%E6%BA%85%E5%B0%84%E7%94%A8%E4%BA%8E%E5%AE%9E%E6%97%B6%E8%BE%90%E5%B0%84%E5%9C%BA%E6%B8%B2%E6%9F%93/" title="论文阅读三十一：3D高斯溅射用于实时辐射场渲染"><img src="/images/3dgs.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读三十一：3D高斯溅射用于实时辐射场渲染"/></a><div class="content"><a class="title" href="/2024/11/18/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B8%89%E5%8D%81%E4%B8%80%EF%BC%9A3D%E9%AB%98%E6%96%AF%E6%BA%85%E5%B0%84%E7%94%A8%E4%BA%8E%E5%AE%9E%E6%97%B6%E8%BE%90%E5%B0%84%E5%9C%BA%E6%B8%B2%E6%9F%93/" title="论文阅读三十一：3D高斯溅射用于实时辐射场渲染">论文阅读三十一：3D高斯溅射用于实时辐射场渲染</a><time datetime="2024-11-18T11:31:56.000Z" title="发表于 2024-11-18 19:31:56">2024-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/18/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B8%89%E5%8D%81%EF%BC%9AMamba2%EF%BC%9ATransformers-are-SSMs/" title="论文阅读三十：Mamba2：Transformers are SSMs"><img src="/images/mamba2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读三十：Mamba2：Transformers are SSMs"/></a><div class="content"><a class="title" href="/2024/11/18/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B8%89%E5%8D%81%EF%BC%9AMamba2%EF%BC%9ATransformers-are-SSMs/" title="论文阅读三十：Mamba2：Transformers are SSMs">论文阅读三十：Mamba2：Transformers are SSMs</a><time datetime="2024-11-18T11:27:24.000Z" title="发表于 2024-11-18 19:27:24">2024-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/18/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%9ALlama3/" title="论文阅读二十九：Llama3"><img src="/images/llama3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读二十九：Llama3"/></a><div class="content"><a class="title" href="/2024/11/18/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%9ALlama3/" title="论文阅读二十九：Llama3">论文阅读二十九：Llama3</a><time datetime="2024-11-18T11:22:37.000Z" title="发表于 2024-11-18 19:22:37">2024-11-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Serge Wang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>