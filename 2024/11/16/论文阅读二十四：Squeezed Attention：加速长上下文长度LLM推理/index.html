<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>论文阅读二十四：Squeezed Attention：加速长上下文长度LLM推理 | Model The World</title><meta name="author" content="Serge Wang"><meta name="copyright" content="Serge Wang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="摘要 新兴的大型语言模型（LLM）应用程序需要长输入提示，以便执行复杂的下游任务，如文档分析和代码生成。对于这些长上下文长度的应用程序，输入提示的长度在推理效率方面构成了重大挑战，因为推理成本随序列长度呈线性增加。然而，对于许多这些应用程序，提示中的大部分上下文在不同的用户输入之间是固定的，从而提供了在接收用户输入时执行离线优化以快速处理用户输入的机会。在这项工作中，我们提出了一种机制来加速LLM">
<meta property="og:type" content="article">
<meta property="og:title" content="论文阅读二十四：Squeezed Attention：加速长上下文长度LLM推理">
<meta property="og:url" content="https://sergewang.github.io/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%9ASqueezed%20Attention%EF%BC%9A%E5%8A%A0%E9%80%9F%E9%95%BF%E4%B8%8A%E4%B8%8B%E6%96%87%E9%95%BF%E5%BA%A6LLM%E6%8E%A8%E7%90%86/">
<meta property="og:site_name" content="Model The World">
<meta property="og:description" content="摘要 新兴的大型语言模型（LLM）应用程序需要长输入提示，以便执行复杂的下游任务，如文档分析和代码生成。对于这些长上下文长度的应用程序，输入提示的长度在推理效率方面构成了重大挑战，因为推理成本随序列长度呈线性增加。然而，对于许多这些应用程序，提示中的大部分上下文在不同的用户输入之间是固定的，从而提供了在接收用户输入时执行离线优化以快速处理用户输入的机会。在这项工作中，我们提出了一种机制来加速LLM">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sergewang.github.io/images/squeeze-attention.png">
<meta property="article:published_time" content="2024-11-16T09:28:36.000Z">
<meta property="article:modified_time" content="2024-11-16T11:18:46.062Z">
<meta property="article:author" content="Serge Wang">
<meta property="article:tag" content="LLM">
<meta property="article:tag" content="论文阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sergewang.github.io/images/squeeze-attention.png"><link rel="shortcut icon" href="/img/newlogo.png"><link rel="canonical" href="https://sergewang.github.io/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%9ASqueezed%20Attention%EF%BC%9A%E5%8A%A0%E9%80%9F%E9%95%BF%E4%B8%8A%E4%B8%8B%E6%96%87%E9%95%BF%E5%BA%A6LLM%E6%8E%A8%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="IDUolVgWkW_cmu1mtW5hsxrrIjQfCHvq5hOTOkXeVNE"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?9dcb7eb7a8a6225c2b1f242f3b0894bf";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-XERFYF0N5K"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-XERFYF0N5K')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-XERFYF0N5K', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '论文阅读二十四：Squeezed Attention：加速长上下文长度LLM推理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-16 19:18:46'
}</script></head><body><div id="web_bg" style="background-image: url(/img/background.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/newlogo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/squeeze-attention.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/newlogo.png" alt="Logo"><span class="site-name">Model The World</span></a><a class="nav-page-title" href="/"><span class="site-name">论文阅读二十四：Squeezed Attention：加速长上下文长度LLM推理</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">论文阅读二十四：Squeezed Attention：加速长上下文长度LLM推理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-16T09:28:36.000Z" title="发表于 2024-11-16 17:28:36">2024-11-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-16T11:18:46.062Z" title="更新于 2024-11-16 19:18:46">2024-11-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LLM/">LLM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="摘要">摘要</h2>
<p>新兴的大型语言模型（LLM）应用程序需要长输入提示，以便执行复杂的下游任务，如文档分析和代码生成。对于这些长上下文长度的应用程序，输入提示的长度在推理效率方面构成了重大挑战，因为推理成本随序列长度呈线性增加。然而，对于许多这些应用程序，提示中的大部分上下文在不同的用户输入之间是固定的，从而提供了在接收用户输入时执行离线优化以快速处理用户输入的机会。在这项工作中，我们提出了一种机制来加速LLM应用程序，其中大部分输入提示是固定的。为了实现这一点，我们首先利用<strong>K-means离线聚类</strong>，根据语义相似性对固定上下文的键进行分组，并用单个质心值表示每个集群。在推理过程中，我们<strong>将用户输入的查询标记与质心进行比较</strong>，以预测固定上下文中的哪些键在语义上相关，需要在推理期间加载。然后，我们<strong>仅使用固定上下文中的这些重要键来计算精确注意力</strong>。该方法在保持模型准确性的同时，显著降低了带宽和计算成本，因为仅使用固定上下文标记的一个子集来计算精确的注意力。我们还扩展了我们的方法，使用分层质心查找来识别重要键，这可以将注意力的复杂性从线性降低到相对于固定上下文长度的对数。为了实现我们方法的效率优势，我们实现了<strong>优化的Triton内核，用于质心比较和稀疏FlashAttention</strong>，并使用重要键，在长上下文推理的预填充和生成阶段实现了4倍以上的加速。此外，我们在各种长上下文基准测试中广泛评估了我们的方法，包括LongBench，它在不损失准确性的情况下将KV缓存预算减少了3.1倍。对于允许精度下降较小的应用，我们可以实现高达8倍的降低，LLaMA-2-7B-32K、LWM-Text-Chat-1M和Longchat-7B-v1.5-32K型号的精度差距小于0.5点。我们的代码可在： <a target="_blank" rel="noopener" href="https://github.com/SqueezeAILab/SqueezedAttention">https://github.com/SqueezeAILab/SqueezedAttention</a> 。</p>
<h2 id="引言">引言</h2>
<p>近年来，大型语言模型（LLMs）得到了快速发展，实现了一系列下游应用，包括文档问答（QA）和对结构化和非结构化文档的复杂分析。这些文档处理和分析任务的性能得益于较新的开源[26,40]和闭源[3,4,15]模型上下文长度的增加，因为这些任务受益于合并大量的输入上下文，以调节模型生成特定的输出。然而，下游应用程序的LLM部署受到推理成本的限制，LLM推理需要大量的计算资源以及内存容量和带宽。特别是，由于KV缓存的大小，长上下文长度应用程序具有较大的内存容量和内存带宽要求，KV缓存的尺寸相对于序列长度呈线性增加[39,17,24]。</p>
<p>对于许多应用程序，如上下文学习、文档QA和代码生成，在一系列提示中，很大一部分输入上下文是固定的。例如，输入上下文可能包含系统指令、文档、源代码，以及目标任务的特定少数场景示例。这个固定的上下文在连续的提示中重复使用，对于将模型定制到目标应用程序非常有益；然而，增加固定上下文的大小对推理效率提出了重大挑战。在整个工作中，我们将<strong>把提示的这一部分称为“固定上下文”</strong>，<strong>将与联机的用户请求相对应的部分称为”用户输入“</strong>。用户输入附加在固定上下文之后，并提供给模型。对于许多长上下文应用程序，提示的固定上下文部分比提示的用户输入部分长得多，并且该固定上下文部分的注意力计算通常主导推理运行时。在这项工作中，我们的目的是利用这样一个事实，即<strong>在推理之前，这个上下文是固定的且可用的</strong>。这使我们能够在处理传入的用户输入和生成输出时<strong>优化对这个固定上下文的关注</strong>。</p>
<p>为此，我们提出了一种通过加速注意力计算来加速固定上下文应用程序的方法——<strong>压缩注意力</strong>。如图1所示，我们的方法通过快速识别固定上下文中的哪些键对给定的查询标记很重要来加速推理。这种方法涉及两阶段算法。在第一阶段，我们<strong>根据键的语义相似性对固定上下文中的键进行离线聚类</strong>，然后使用单个代表性的”键质心“表示同一聚类中的键。这种离线聚类可以在推理过程中快速检索重要键（即与传入查询标记语义上最相关的键）。在第二阶段，当收到用户输入时，我们首先<strong>将查询标记与键质心进行比较</strong>，而不是与整个键集进行比较，以识别重要的键簇，从而检索重要的键。一旦识别出重要的集群，我们就会检索它们的相关的键，并仅使用那些<strong>高分键计算精确的注意力</strong>。我们的方法可以进一步扩展到<strong>分层聚类和检索方案</strong>，如图1所示，通过<strong>首先利用粗粒度聚类，然后使用细粒度聚类细化搜索</strong>，有效地缩小了搜索空间。正如我们稍后将在第3.4节中讨论的那样，这种方法可以将查找的内存和计算复杂度降低到相对于固定上下文长度的对数复杂度。</p>
<p><img src="hierarchical-clustering.png" alt=""></p>
<p>与现有的解决方案[46,24,14]不同，这些解决方案只识别一次不太重要的标记并在整个生成过程中丢弃它们，我们的方法<strong>动态地识别和检索与每个生成步骤语义相关的信息</strong>。这使得我们的方法能够保持生成质量，同时<strong>将从内存加载的KV缓存条目的数量减少多达8倍</strong>（包括加载键质心），如第6节所述。通过优化内存带宽和计算成本，SQUEEZED ATTENTION有效地降低了长上下文推理过程中生成和预填充的开销。具体来说，我们的工作对加速长上下文长度应用程序做出了以下贡献：</p>
<ul>
<li>
<p><strong>基于语义的键聚类和检索</strong>：为了根据非连续键的语义相似性对其进行聚类，我们离线执行K-means聚类，用单个“键质心”值表示每个集群内的所有键（第3.1节）。这使得在推理过程中能够进行高效检索，使我们能够通过将查询与键簇而不是整个键集进行比较来识别与查询标记语义上最相关的键（第3.2节）。由于键质心的数量明显小于键的总数，因此内存开销仍然很小。然后，仅使用检索到的键计算确切的注意力得分。我们还提出了我们方法的分层版本，它可以将每个标记生成的内存和计算复杂度从线性降低到相对于上下文长度的对数。</p>
</li>
<li>
<p><strong>系统实现</strong>：为了实现我们方法的效率优势，我们设计了高效的Triton内核，用于执行质心比较（第4.1节）和仅使用重要键计算稀疏FlashAttention（第4.2节）。结合在一起，当使用长固定上下文运行推理时，我们的方法在预填充和解码阶段分别实现了4.3倍和4.2倍的加速。对于允许精度下降较小的应用，我们可以实现高达8倍的降低，LLaMA-2-7B-32K、LWM-Text-Chat-1M和Longchat-7B-v1.5-32K型号的精度差距小于0.5点（第6.3节）。</p>
</li>
<li>
<p><strong>基准</strong>：目前很少有长上下文QA基准数据集来代表用户对文档/知识源提出不同问题的应用程序。为了解决这个问题，我们引入了PreFixQA，这是一个文档QA基准测试，其中包含一系列arXiv文档，每个文档都有许多针对固定知识源的合成用户输入问题和答案对。该基准允许我们评估每个文档的各种用户输入，从而促进了对固定上下文方法的研究（第5节）。</p>
</li>
<li>
<p><strong>评估</strong>：我们在不同的长上下文基准上广泛评估了我们的方法，包括LongBench[5]、RULER[18]和PreFixQA。特别是，在LongBench上，我们的方法保留了完整的KV缓存精度，减少了3.1×KV的预算。对于能够容忍微小精度下降的应用，SQUEEZED ATTENTION实现了高达8×KV的预算削减，精度下降不到0.5点（第6节）。</p>
</li>
</ul>
<h2 id="相关工作">相关工作</h2>
<h3 id="长上下文LLMs">长上下文LLMs</h3>
<p>随着长上下文应用程序的日益普及，LLM不断发展，可以支持超过100K甚至高达1M标记的上下文长度。这包括GPT-4-Turbo[3]、Claude-2[4]和Gemini 1.5[15]等专有模型，它们分别支持高达128K、200K和1M标记的上下文长度。在开源方面，已经做出了几项努力，将上下文长度扩展到原始模型训练的长度之外[23,7]。一项值得注意的工作是大世界模型（LWM）[26]，它已经证明将Llama 2[41]的上下文长度扩展到1M标记。然而，随着上下文长度的增加，KV缓存往往成为关键的瓶颈，严重影响LLM推理过程中的内存使用和延迟[39,17]。因此，在使用长上下文模型时，<strong>KV缓存压缩方法</strong>已成为实现高效推理的关键问题。</p>
<h3 id="用于长上下文推理的KV缓存压缩">用于长上下文推理的KV缓存压缩</h3>
<p>为了通过减小KV缓存大小来实现更有效的长上下文推理，已经提出了几种方法，包括<strong>量化</strong>[17,29,19,27]、<strong>跨标记[32]和层[6]共享KV缓存</strong>以及<strong>标记修剪</strong>[13]。将更详细讨论的一种值得注意的方法是<strong>KV缓存稀疏化</strong>，它遵循了先前在注意力稀疏化方面的工作[38,8,44]。KV缓存稀疏化有两个主要方向：<strong>KV缓存驱逐</strong>和<strong>稀疏加载KV缓存</strong>。</p>
<p>KV缓存删除。KV删除已成为一种广泛使用的方法，通过<strong>识别和删除不太重要的标记</strong>来压缩KV缓存。已经提出了各种策略来确定标记重要性，包括<strong>注意力得分贡献</strong>[46,35]、<strong>生成过程中的持续注意力模式</strong>[28]、<strong>标记熵</strong>[43]和其他基于启发式的策略[14]。</p>
<p>然而，在<strong>长上下文提示后面跟着不同问题的用例</strong>中，KV缓存对上下文的重要性应该根据其与后续问题的相关性来决定。为了解决这个问题，SnapKV[24]建议仅根据最新提示标记对输入提示其余部分的关注度得分来选择KV缓存条目。然而，由于<strong>输入提示中的重要标记是一次确定的，并且在整个生成过程中保持不变</strong>，因此它无法适应生成过程中或响应后续用户输入时不断变化的标记重要性。InfiniPot[21]通过根据上下文与预定义的任务特定提示的相关性迭代压缩上下文来扩展这一想法，这些提示类似于潜在的输入问题。然而，使用代理提示离线选择重要标记可能无法准确反映未来的查询。</p>
<p>同样，基于驱逐的方法会丢弃标记，并在整个生成过程中保留剩余的标记，这可能会忽视这样一个事实，即<strong>丢弃的标记在过程的后期可能会变得很重要</strong>。另一方面，通过对KV缓存进行聚类，并通过高效的质心查找<strong>仅检索最相关的集群</strong>，从而避免了对完整KV缓存查找的需要。这种方法足够轻，可以在每个生成步骤中应用，从而确保为每个查询标记检索相关上下文。</p>
<p><strong>稀疏KV缓存加载</strong>。之前探索的一个方向是<strong>存储完整的KV缓存，但只在推理过程中动态加载相关的键和值</strong>。QUEST[39]对连续的KV缓存条目进行聚类，并在生成过程中根据它们与每个查询标记的相关性动态检索最相关的聚类。</p>
<p>这里的另一项相关工作是应用<strong>快速核求和方法</strong>[16,42,22,31,30]，特别是<strong>快速多极方法</strong>（FMM）的变体[9]，这些方法最初是为了加速<strong>N体模拟</strong>而提出的。在Transformers的背景下，[20]的最新工作<strong>利用FMM对连续的过去标记进行聚类，并将较粗粒度的聚类分配给较旧的标记</strong>，从而减少了存储整个过去标记的内存开销。然而，这种方法以及QUEST[39]都依赖于<strong>物理接近度</strong>进行聚类，而在自然语言应用程序中，聚类应该基于<strong>语义接近度</strong>，因为<strong>物理上相距很远的标记在语义上可能是相似的</strong>。这是因为相距甚远的标记在语义上可能是相关的，反之亦然。SQUEEZED ATTENTION通过<strong>基于嵌入相似性对标记进行聚类来解决这个问题</strong>，确保为未来生成检索语义相关的标记。</p>
<p>另一项先前的工作旨在利用<strong>向量搜索方法</strong>仅加载重要的键和值。PQCache[45]应用了基于乘积量化的矢量搜索来识别重要键。RetrievalAttention[25]使用基于K近邻的向量搜索方法，该方法将重要键和值的动态检索卸载到CPU上。然而，这些先前的方法仅限于生成阶段，并不能加速<strong>预填充</strong>，而预填充对于减少<strong>首次标记时间</strong>（TTFT）延迟至关重要。</p>
<p>与利用向量搜索方法的先前工作相比，SQUEEZED ATTENTION使用快速质心查找来准确检索GPU上的相关上下文，而不需要将操作卸载到CPU，如[25]所示。我们的方法还能够加速预填充和生成。此外，我们的方法允许从不同的头部加载更多或更少的键，具体取决于每个头部的重要键数量。这种方法使我们能够实现更高的精度，同时积极减少KV条目的数量。</p>
<h2 id="算法">算法</h2>
<p>我们设计了一种<strong>离线预处理固定上下文的方法，这样在推理时我们就可以快速确定哪些信息是重要的，并且只加载这些信息</strong>。在3.1节中，我们讨论了如何根据固定上下文键的语义相似性对其进行离线聚类，然后为每个聚类确定一个代表性质心。在第3.2节中，我们提出了一种方法，可以根据推理过程中的输入查询来识别哪些集群是最重要的，以便进行精确的注意力计算。最后，在第3.3节中，我们扩展了我们的算法，以包括多级质心，从而加速对重要键标记的搜索，从而提高了我们的方法在较长上下文长度下的可扩展性。</p>
<h3 id="离线：聚类键">离线：聚类键</h3>
<p>我们方法的第一步是离线预处理固定的上下文键，如图2所示。我们<strong>采用固定的上下文键，并根据余弦相似度对其进行聚类</strong>。具体来说，我们使用K-means聚类和归一化键向量将相似的键分组在一起。然后，我们通过取簇中所有向量的平均值来计算每个簇的质心。该集群质心可以用作该集群中所有标记的代表性键标记；通过将传入查询与此质心进行比较，我们可以确定该集群中的标记是否重要，而不必将其与单个键进行比较。</p>
<p><img src="clustering-offline.png" alt=""></p>
<p>请注意，这种<strong>基于语义的聚类方法将非连续的键标记组合在一起</strong>，这可能会使从内存中高效加载键变得更加困难。然而，在现代LLM中，单个头的每个KV缓存标记的大小通常大于bf16中的256字节（因为头尺寸通常大于128）[40,41]，这足以有效地利用内存带宽。因此，当从内存中稀疏地加载非连续键和相关值时，我们仍然能够有效地执行内存操作。</p>
<h3 id="在线：查询感知键检索">在线：查询感知键检索</h3>
<p>理想情况下，我们只加载注意力得分高的键。但是，如果不对键进行完整传递，就无法提前知道给定查询中哪些键得分高。在我们的方法中，我们<strong>使用质心聚类来近似测量聚类内键的“平均”注意力得分</strong>，从而允许我们在不加载所有键的情况下识别重要键。</p>
<p><img src="important-keys.png" alt=""></p>
<p>通过将键组织成簇，每个簇由一个质心表示，我们可以加速对传入用户输入的推理，如图3所示。我们<strong>首先将输入的查询标记与每个键质心进行比较，以评估哪些键标记可能具有较高的注意力得分</strong>。为了估计集群i对查询标记q的重要性，我们计算该集群的注意力估计为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mfrac><mrow><mtext>exp</mtext><mo stretchy="false">(</mo><mi>q</mi><msubsup><mi>C</mi><mi>i</mi><mi>T</mi></msubsup><mo stretchy="false">)</mo></mrow><mrow><munder><mo>∑</mo><mi>j</mi></munder><msub><mi>N</mi><mi>j</mi></msub><mo>⋅</mo><mtext>exp</mtext><mo stretchy="false">(</mo><mi>q</mi><msubsup><mi>C</mi><mi>j</mi><mi>T</mi></msubsup><mo stretchy="false">)</mo></mrow></mfrac><mtext> </mtext><mo separator="true">,</mo></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">S_i = \frac{\text{exp}(qC_i^T)}{\sum_j N_j \cdot \text{exp}(qC_j^T)}\,, \tag{1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.6673em;vertical-align:-1.1489em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183em;"><span style="top:-2.2869em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord text"><span class="mord">exp</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8231em;"><span style="top:-2.4231em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.413em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">exp</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.4413em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1489em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span></span><span class="tag"><span class="strut" style="height:2.6673em;vertical-align:-1.1489em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">N_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 是集群j中的键数量， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">C_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 是集群j的集群质心。这使我们能够评估集群i中标记的平均重要性。如果集群的平均重要性高于所需的阈值，我们加载该集群的键并执行精确的注意力计算；否则，我们避免使用这些键加载和执行计算。</p>
<p>使用Softmax估计 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 而不是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><msubsup><mi>C</mi><mi>i</mi><mi>T</mi></msubsup></mrow><annotation encoding="application/x-tex">qC_i^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1em;vertical-align:-0.2587em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.4413em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span> 作为每个集群的重要性度量，提供了一种简单的方法来<strong>控制从每个注意力头部检索到的重要键的数量</strong>。如附录A.2所述，一些注意力头的注意力得分分布更为均衡，导致重要键的数量更多，而另一些注意力头的注意力得分分布更为偏斜，只显示了几个重要键。理想情况下，我们希望<strong>从具有大量重要键的头部检索更多键</strong>。由于Softmax值被归一化为1，我们可以在所有层和注意力头上应用一个<strong>全局阈值</strong>来实现这一点。这使我们能够自动从具有平衡注意力得分分布的头部检索更多键，其中更多的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 值超过阈值；并且来自具有偏斜分布的注意力头的键更少，其中超过阈值的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 值更少。这种方法消除了手动配置每个注意力头要检索的键数量的需要。<strong>一旦我们选择了达到所需稀疏度的阈值，它就会在预填充和生成阶段保持不变</strong>。</p>
<h3 id="分层质心查找">分层质心查找</h3>
<p>第3.1节和第3.2节中概述的质心查找方法允许快速确定哪些键在注意力计算中可能很重要，然后只使用这些键计算注意力。只要我们使用细粒度的质心，我们就可以有足够的分辨率来识别哪些键是重要的，并且我们可以保持准确性。然而，<strong>最好保留较少的质心</strong>，因为较多的质心会导致质心查找的成本增加。</p>
<p>为了<strong>在保持使用粗粒度质心的效率优势的同时提高细粒度质心查找的精度，我们利用了分层质心查找过程</strong>。图2展示了我们在离线预处理固定上下文键期间的（两级）分层方法。最初，使用与第3.1节中相同的方法，我们将键聚类到更多的质心中，称为<strong>2级质心</strong>。然后，我们对这些2级质心进行<strong>额外的K-means聚类</strong>，以产生较少数量的粗粒度质心，称为<strong>1级质心</strong>。</p>
<p>在推理过程中，我们执行如图3所示的分层质心查找。我们首先将传入查询和粗粒度的1级质心进行比较，以快速删除不必要的键。这种初始查找缩小了搜索范围，使我们能够专注于将查询与可能得分较高的细粒度2级质心进行比较。具体来说，我们首先将输入查询标记q与每个粗粒度键质心 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">C_i^{(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3217em;vertical-align:-0.2769em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span></span></span></span> 进行比较，以评估哪些键标记可能具有较高的注意力得分：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><msubsup><mi>S</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mfrac><mrow><mtext>exp</mtext><mo stretchy="false">(</mo><mi>q</mi><msubsup><mi>C</mi><mi>i</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mi>T</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow><mrow><munder><mo>∑</mo><mi>j</mi></munder><msubsup><mi>N</mi><mi>j</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>⋅</mo><mtext>exp</mtext><mo stretchy="false">(</mo><mi>q</mi><msubsup><mi>C</mi><mi>j</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mi>T</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow></mfrac><mtext> </mtext><mi mathvariant="normal">.</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(2)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">S_i^{(1)} = \frac{\text{exp}(qC_i^{(1)T})}{\sum_j N_j^{(1)}\cdot \text{exp}(qC_j^{(1)T})}\,. \tag{2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3217em;vertical-align:-0.2769em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.0924em;vertical-align:-1.3706em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7218em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.0448em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4358em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.413em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord text"><span class="mord">exp</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.413em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.2748em;"><span class="pstrut" style="height:3.0448em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7218em;"><span class="pstrut" style="height:3.0448em;"></span><span class="mord"><span class="mord text"><span class="mord">exp</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2769em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3706em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span><span class="tag"><span class="strut" style="height:3.0924em;vertical-align:-1.3706em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>然后，我们应用阈值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 来排除粗粒度级别的低得分集群。这种过滤使我们能够避免对不太可能得分高的标记的细粒度2级质心进行任何比较。对于剩余的1级质心，我们将其扩展到相应的细粒度2质心 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>C</mi><mi mathvariant="script">l</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">C_{\mathcal{l}}^{(2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3461em;vertical-align:-0.3013em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.3987em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013em;"><span></span></span></span></span></span></span></span></span></span> 中，然后将其与输入查询标记q进行比较以评估它们的相关性：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><msubsup><mi>S</mi><mi mathvariant="script">l</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><mfrac><mrow><mtext>exp</mtext><mo stretchy="false">(</mo><mi>q</mi><msubsup><mi>C</mi><mi mathvariant="script">l</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mi>T</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow><mrow><munder><mo>∑</mo><mi>m</mi></munder><msubsup><mi>N</mi><mi>m</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msubsup><mo>⋅</mo><mtext>exp</mtext><mo stretchy="false">(</mo><mi>q</mi><msubsup><mi>C</mi><mi>m</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mi>T</mi></mrow></msubsup><mo stretchy="false">)</mo></mrow></mfrac><mtext> </mtext><mi mathvariant="normal">.</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(3)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">S_{\mathcal{l}}^{(2)} = \frac{\text{exp}(qC_{\mathcal{l}}^{(2)T})}{\sum_m N_m^{(2)}\cdot \text{exp}(qC_m^{(2)T})}\,. \tag{3}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3461em;vertical-align:-0.3013em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.3987em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.9706em;vertical-align:-1.2345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7361em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.0448em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0017em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.5834em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1166em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord text"><span class="mord">exp</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.5834em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1166em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.2748em;"><span class="pstrut" style="height:3.0448em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7361em;"><span class="pstrut" style="height:3.0448em;"></span><span class="mord"><span class="mord text"><span class="mord">exp</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.3987em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">.</span></span><span class="tag"><span class="strut" style="height:2.9706em;vertical-align:-1.2345em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>由于我们只考虑剩余的2级质心，因此分母也是基于这些选定的质心计算的。然后，我们将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>S</mi><mi mathvariant="script">l</mi><mrow><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">S_{\mathcal{l}}^{(2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3461em;vertical-align:-0.3013em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.3987em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013em;"><span></span></span></span></span></span></span></span></span></span> 与阈值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 进行比较，以决定哪些键应用于精确的注意力计算。通过这种分层方法，我们可以降低细粒度质心查找的成本，同时保持其准确性。虽然为了清楚起见，我们在这里描述了一个2级过程，但这种方法可以扩展到多个层次结构。</p>
<h3 id="复杂性分析">复杂性分析</h3>
<p>让L表示上下文长度，在长提示应用程序中，上下文长度可能很大。在基线方法（即<strong>标准自回归生成</strong>）中，每个生成步骤都需要将查询标记与提示中的整个键集进行比较，从而每次迭代（即每次标记生成）产生O(L)内存和计算操作。然而，如果我们应用1级检索，我们可以使用c质心来识别相关的键簇，然后仅使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>≪</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">k \ll L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 检索到的键来计算注意力。这将每次迭代的内存和计算复杂度降低到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>c</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(c + k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 。1级检索方法的一个局限性是，<strong>显著减少c（质心数量）可能具有挑战性，因为它需要将大量键聚类到每个簇中</strong>。这可能会导致过于<strong>激进地修剪键，或者检索同一集群中分组在一起的不相关的键</strong>。</p>
<p>相比之下，分层质心检索通过逐步修剪键，可以<strong>更有效地减少层次结构每一级的质心</strong>。假设我们在每个层次级别使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>≪</mo><mi>c</mi><mo>&lt;</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">c&#x27; \ll c \lt L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.791em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> 簇，并且在每个阶段只检索这些簇的一小部分，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>p</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \lt p \lt 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。在这种设置中，我们需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal">gL</span><span class="mclose">)</span></span></span></span> 层次级别来将键减少到所需的最终计数k。因此，每一生成迭代的内存和计算复杂度变为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>c</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mtext>log</mtext><mi>L</mi><mo>+</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(c&#x27;\text{log}L + k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0019em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord text"><span class="mord">log</span></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> ，将复杂度从<strong>线性降低到与上下文长度相关的对数</strong>。</p>
<h2 id="系统实现">系统实现</h2>
<p>为了实现我们方法的效率优势，我们设计了<strong>Triton[33]内核</strong>，以便在推理过程中高效地在线计算流水线的每个阶段。第一阶段（第4.1节）根据第3节中讨论的算法<strong>计算质心查找</strong>，以确定我们必须精确计算注意力的标记。第二阶段（第4.2节）利用此信息（i）<strong>仅加载重要键</strong>，并（ii）<strong>仅使用重要键执行注意力计算</strong>，从而节省计算和内存带宽。对于具有长固定上下文的长上下文应用程序，固定上下文的KV缓存可以与传入用户输入动态生成的KV缓存<strong>分开缓存</strong>。</p>
<h3 id="质心查找">质心查找</h3>
<p>我们内核实现的第一阶段是，比较查询标记和固定上下文键质心。这些查询标记可能包含多个标记，来自预填充阶段输入的用户输入或生成阶段的单一标记。内核遵循与<strong>FlashAttention-2[10]类似的并行化策略</strong>，在FlashAttention 2[10]中，我们<strong>沿着查询序列长度维度在不同的注意力头上进行划分</strong>。我们首先加载一组查询标记，并迭代整个键质心，以便根据方程1找到最重要的键质心。在较高层次上，内核对键质心执行初始传递，以基于查询键质心点积计算方程1中的分母。然后，使用第一遍的分母结果，对质心进行第二遍计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，如方程式1所示。最后，我们将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与目标阈值T进行比较，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>&lt;</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">S_i\lt T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> ，我们只加载簇i中的键。在预填充和生成阶段如何应用此过程的详细信息将在以下小节中讨论。</p>
<p><strong>预填充阶段</strong>。在预填充过程中，当有多个查询标记可用时，我们按照FlashAttention-2[10]中的<strong>查询序列长度维度分割</strong>工作负载，以获得额外的并行性。由于此过程会为每个查询标记生成单独的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 值，因此我们计算它们的平均值以获得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>S</mi><mo>ˉ</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\bar{S}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9701em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，即所有查询标记中每个键集群的平均重要性得分。然后，我们检查<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>S</mi><mo>ˉ</mo></mover><mi>i</mi></msub><mo>&lt;</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\bar{S}_i \lt T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9701em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8201em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span><span style="top:-3.2523em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">ˉ</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> ，以确定是否在相应的集群中加载键。由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是Softmax值的估计值，该值被归一化为1，因此对查询标记进行平均提供了一种计算其组合重要性得分的简单方法。</p>
<p><strong>生成阶段</strong>。在生成过程中，实现并行性更具挑战性，因为我们<strong>无法在查询序列的长度维度上利用并行性</strong>。在处理小批量时，这尤其成问题，因为在这种情况下，我们<strong>唯一可以利用的并行性是跨不同的头</strong>。为了在生成过程中加速质心查找，我们在计算分母 $ D = \sum_j N_j \cdot \text{exp}(qC_j^T)$ 时，在第一次遍历键质心时，额外计算并存储每个簇的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>exp</mtext><mo stretchy="false">(</mo><mi>q</mi><msubsup><mi>C</mi><mi>j</mi><mi>T</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{exp}(qC_j^T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2361em;vertical-align:-0.3948em;"></span><span class="mord text"><span class="mord">exp</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.4413em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。然后，在第二轮中，我们加载预先计算的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>exp</mtext><mo stretchy="false">(</mo><mi>q</mi><msubsup><mi>C</mi><mi>j</mi><mi>T</mi></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{exp}(qC_j^T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2361em;vertical-align:-0.3948em;"></span><span class="mord text"><span class="mord">exp</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.4413em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 值，并将其与DT进行比较，以确定每个集群的重要性，而不需要显式计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。第二轮可以在集群维度上并行化，以便快速比较。如附录B所强调的，这些优化对于在生成过程中执行质心查找至关重要，而不会产生大量的延迟开销。</p>
<h3 id="检索键的稀疏注意力">检索键的稀疏注意力</h3>
<p>一旦通过质心查找确定了重要键，我们系统实现的第二阶段将<strong>利用稀疏FlashAttention内核在预填充和生成阶段实现加速</strong>。该阶段还使用与FlashAttention-2类似的并行化策略，通过<strong>在头部和序列长度维度上分割</strong>工作[10]。我们的内核实现建立在先前针对FlashAttention-2[34]和动态稀疏FlashAttention[36]的Triton实现的基础上。<strong>内核首先加载查询向量，然后迭代需要选择性加载的键索引张量</strong>。然后，这些索引用于从内存中加载相应的键并计算精确的注意力。</p>
<p>在计算对固定上下文的注意力时，另一个挑战是<strong>重要键标记在不同头部之间的不平衡分布</strong>，这在附录A.2的图A.2中得到了突出显示。在FlashAttention-2中使用默认并行化策略时，<strong>如果一个头包含比其他头更多的重要键，它的运行时间将明显更长</strong>，从而阻碍了加速。为了在这些场景中获得延迟优势，我们根据单个流式多处理器（SM）要计算的固定数量的所需键和值，沿着<strong>序列长度维度分割键和值</strong>（如Flash Decoding[11]所示）。这意味着，如果需要<strong>为特定头部计算更多的键和值</strong>（由于不同头部的稀疏性不平衡），则该头部的工作将在GPU中的更多SM上并行化。内核的设计分为两个阶段，就像Flash解码一样。第一阶段计算每个有效键和值块的部分注意力输出。第二阶段合并部分注意力输出，同时使用部分Softmax分母和最大值校正输出。</p>
<h2 id="固定上下文处理基准">固定上下文处理基准</h2>
<h2 id="结论">结论</h2>
<p>在这项工作中，我们提出了一种在长上下文应用中加速注意力的方法。我们的方法将按键分组，并使用每组的代表性质心来快速识别哪些按键对注意力操作很重要。对于固定上下文应用程序，我们可以使用K-means离线对密钥进行聚类。在推理过程中，我们首先将新的输入查询与代表性质心进行比较，然后只计算这些重要键的精确注意力。我们的方法可以扩展到分层检索方案，这可以将查找的内存和计算复杂度降低到相对于固定上下文长度的对数复杂度。在预填充和用于长上下文推理的解码阶段中，SQUEZED ATTENTION能够提供4.3×/4.2×的加速，同时保持准确性。此外，我们还概述了如何使用分层质心查找来扩展我们的算法，使我们能够在保持粗粒度质心效率的同时实现细粒度质心查找的准确性，从而提高我们的方法在较长上下文长度下的可扩展性。我们的方法在保持准确性的同时，加速了固定上下文应用程序的长上下文长度LLM推理。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://SergeWang.github.io">Serge Wang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://sergewang.github.io/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%9ASqueezed%20Attention%EF%BC%9A%E5%8A%A0%E9%80%9F%E9%95%BF%E4%B8%8A%E4%B8%8B%E6%96%87%E9%95%BF%E5%BA%A6LLM%E6%8E%A8%E7%90%86/">https://sergewang.github.io/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%9ASqueezed%20Attention%EF%BC%9A%E5%8A%A0%E9%80%9F%E9%95%BF%E4%B8%8A%E4%B8%8B%E6%96%87%E9%95%BF%E5%BA%A6LLM%E6%8E%A8%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://SergeWang.github.io" target="_blank">Model The World</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LLM/">LLM</a><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">论文阅读</a></div><div class="post-share"><div class="social-share" data-image="/images/squeeze-attention.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%9AMagicQuill%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%99%BA%E8%83%BD%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%9B%BE%E5%83%8F%E7%BC%96%E8%BE%91%E7%B3%BB%E7%BB%9F/" title="论文阅读二十五：MagicQuill：一个智能交互式图像编辑系统"><img class="cover" src="/images/magicquill.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">论文阅读二十五：MagicQuill：一个智能交互式图像编辑系统</div></div><div class="info-2"><div class="info-item-1">摘要 作为一种高度实用的应用程序，图像编辑会遇到各种用户需求，因此优先考虑出色的易用性。在本文中，我们推出了MagicQuill，这是一个集成的图像编辑系统，旨在支持用户快速实现他们的创造力。我们的系统从一个流线型但功能强大的界面开始，使用户只需几笔就能表达他们的想法（例如，插入元素、擦除对象、更改颜色等）。然后，这些交互由多模态大型语言模型（MLLM）监控，以实时预测用户意图，从而绕过了提示输入的需要。最后，我们应用了强大的扩散先验，并通过精心学习的双分支插件模块进行了增强，以精确控制的方式处理编辑请求。请访问 https://magicquill.art/demo/...</div></div></div></a><a class="pagination-related" href="/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%9B%B6%E6%A0%B7%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%B5%8B%E8%AF%95%E7%9A%84LLM%E5%B9%BB%E8%A7%89%E6%8E%A8%E7%90%86/" title="论文阅读二十三：基于零样本知识测试的LLM幻觉推理"><img class="cover" src="/images/hallucination-reasoning.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">论文阅读二十三：基于零样本知识测试的LLM幻觉推理</div></div><div class="info-2"><div class="info-item-1">摘要 LLM幻觉，LLM偶尔会产生不忠实的文本，对其实际应用构成了重大挑战。大多数现有的检测方法依赖于外部知识、LLM微调或幻觉标记的数据集，并且它们不能区分不同类型的幻觉，而幻觉对于提高检测性能至关重要。我们引入了一个新的任务，幻觉推理，它将LLM生成的文本分为三类：对齐、未对齐和伪造。我们新颖的零样本方法评估LLM是否对给定的提示和文本有足够的知识。我们在新数据集上进行的实验证明了我们的方法在幻觉推理中的有效性，并强调了它对提高检测性能的重要性。...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/11/03/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B8%83%EF%BC%9ALLAMAFACTORY%EF%BC%9A100%E5%A4%9A%E7%A7%8D%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%9F%E4%B8%80%E9%AB%98%E6%95%88%E5%BE%AE%E8%B0%83/" title="论文阅读七：LLaMA-Factory：100多种语言模型的统一高效微调"><img class="cover" src="/2024/11/03/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B8%83%EF%BC%9ALLAMAFACTORY%EF%BC%9A100%E5%A4%9A%E7%A7%8D%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%9F%E4%B8%80%E9%AB%98%E6%95%88%E5%BE%AE%E8%B0%83/architecture.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-03</div><div class="info-item-2">论文阅读七：LLaMA-Factory：100多种语言模型的统一高效微调</div></div><div class="info-2"><div class="info-item-1"> 摘要 高效的微调对于使大型语言模型（LLM）适应下游任务至关重要。然而，在不同的模型上实现这些方法需要付出巨大的努力。我们介绍LLAMAFACTORY，这是一个整合了一套尖端高效训练方法的统一框架。它提供了一种解决方案，可以灵活地定制100多个LLM的微调，而无需通过内置的web UI LLAMABOARD进行编码。我们实证验证了我们的框架在语言建模和文本生成任务上的效率和有效性。它已发布于 https://github.com/hiyouga/LLaMA-Factory ，并获得了25000多颗星和3000个fork。 引言 大型语言模型（LLM）（赵等人，2023）具有显著的推理能力，并赋予了广泛的应用，如问答（Jiang等人，2023b）、机器翻译（Wang等人，2023c；Jiao等人，2023a）和信息提取（Jiao等人（2023b））。随后，大量LLM被开发出来，并可通过开源社区访问。例如，Hugging...</div></div></div></a><a class="pagination-related" href="/2024/11/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B9%9D%EF%BC%9AOPENCODER%EF%BC%9A%E9%A1%B6%E7%BA%A7%E4%BB%A3%E7%A0%81LLM%E7%9A%84%E5%BC%80%E6%94%BE%E6%89%8B%E5%86%8C/" title="论文阅读九：OPENCODER：顶级代码LLM的开放手册"><img class="cover" src="/images/opencoder.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-10</div><div class="info-item-2">论文阅读九：OPENCODER：顶级代码LLM的开放手册</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%9A%E5%9F%BA%E4%BA%8E%E9%9B%B6%E6%A0%B7%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%B5%8B%E8%AF%95%E7%9A%84LLM%E5%B9%BB%E8%A7%89%E6%8E%A8%E7%90%86/" title="论文阅读二十三：基于零样本知识测试的LLM幻觉推理"><img class="cover" src="/images/hallucination-reasoning.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-16</div><div class="info-item-2">论文阅读二十三：基于零样本知识测试的LLM幻觉推理</div></div><div class="info-2"><div class="info-item-1">摘要 LLM幻觉，LLM偶尔会产生不忠实的文本，对其实际应用构成了重大挑战。大多数现有的检测方法依赖于外部知识、LLM微调或幻觉标记的数据集，并且它们不能区分不同类型的幻觉，而幻觉对于提高检测性能至关重要。我们引入了一个新的任务，幻觉推理，它将LLM生成的文本分为三类：对齐、未对齐和伪造。我们新颖的零样本方法评估LLM是否对给定的提示和文本有足够的知识。我们在新数据集上进行的实验证明了我们的方法在幻觉推理中的有效性，并强调了它对提高检测性能的重要性。...</div></div></div></a><a class="pagination-related" href="/2024/11/16/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%9A%E6%9C%89%E9%99%90%E6%95%B0%E6%8D%AE%E5%BE%AE%E8%B0%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97/" title="论文阅读二十二：有限数据微调语言模型实用指南"><img class="cover" src="/images/finetune-methods.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-16</div><div class="info-item-2">论文阅读二十二：有限数据微调语言模型实用指南</div></div><div class="info-2"><div class="info-item-1">摘要 使用预训练大型语言模型（LLMs）已经称为自然语言处理（NLP）中的事实标准，尽管它们需要大量数据。受最近以有限数据训练LLM为重点的研究激增的启发，特别是在低资源领域和语言中，本文调查了最近的迁移学习方法，以优化数据稀缺的下游任务中的模型性能。我们首先解决初始化和持续的预训练策略，以更好地利用未知领域和语言的先验知识。然后，我们研究如何在微调和少样本学习过程中最大限度地利用有限的数据。最后一节从特定任务的角度，回顾了适用于不同数据稀缺程度的模型和方法。我们的目标是为从业者提供实用的指导方针，以克服数据受限带来的挑战，同时突出未来研究的有前景的方向。论文地址 引言 预训练语言模型（PLMs）正在改变NLP领域，显示出学习和建模来自复杂和多样化领域的自然语言数据底层分布的出色能力（Han等人，2021）。然而，他们的训练需要大量的数据和计算资源，这在许多现实世界场景中可能是令人望而却步的（Bai et al.，2024），尤其是对于英语以外的语言和专业领域，例如医学（Crema et al.，2023；Van Veen et al.，2021）、化学（Jablonka et...</div></div></div></a><a class="pagination-related" href="/2024/11/14/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%8C%E5%8D%81%EF%BC%9A%E4%BC%98%E5%8C%96%E7%BC%A9%E6%94%BELLM%E6%B5%8B%E8%AF%95%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97%E6%AF%94%E7%BC%A9%E6%94%BE%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E6%9B%B4%E6%9C%89%E6%95%88/" title="论文阅读二十：优化缩放LLM测试时间计算比缩放模型参数更有效"><img class="cover" src="/images/test-time-inference.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-14</div><div class="info-item-2">论文阅读二十：优化缩放LLM测试时间计算比缩放模型参数更有效</div></div><div class="info-2"><div class="info-item-1">使LLM能够通过使用更多的测试时间计算来提高其输出，是构建可以在开放式自然语言上运行的一般自我改进代理的关键一步。本文研究了LLM中推理时间计算的缩放，重点回答了以下问题：如果允许LLM使用固定但非微不足道的推理时间计算，那么它在具有挑战性的提示下能提高多少性能？回答这个问题不仅对LLM的可实现性能有影响，而且对LLM预训练的未来以及如何权衡推理时间和预训练计算也有影响。尽管它很重要，但很少有研究试图了解各种测试时间推理方法的缩放行为。此外，目前的工作在很大程度上为其中一些策略提供了负面结果。在这项工作中，我们分析了两种主要的机制来扩展测试时间计算：（1）针对密集的、基于过程的验证者奖励模型进行搜索；以及（2）在测试时给出提示的情况下自适应地更新模型在响应上的分布。我们发现，在这两种情况下，缩放测试时间计算的不同方法的有效性因提示的难度而异。这一观察结果促使应用...</div></div></div></a><a class="pagination-related" href="/2025/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%94%E5%8D%81%E4%BA%94%EF%BC%9ATransformer2%EF%BC%9A%E8%87%AA%E9%80%82%E5%BA%94LLMs/" title="论文阅读五十五：Transformer2：自适应LLMs"><img class="cover" src="/images/transformer2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-15</div><div class="info-item-2">论文阅读五十五：Transformer2：自适应LLMs</div></div><div class="info-2"><div class="info-item-1">摘要 自适应大型语言模型（LLM）旨在解决传统微调方法带来的挑战，这些方法通常计算密集，处理各种任务的能力是静态的。我们介绍了Transformer2，这是一种新颖的自适应框架，通过选择性地仅调整LLM权重矩阵的奇异分量，实时调整LLM以适应看不见的任务。在推理过程中，Transformer2采用了两步机制：首先，调度系统识别任务属性，然后使用强化学习训练的特定于任务的“专家”向量被动态混合，以获得传入提示的目标行为。我们的方法优于LoRA等无处不在的方法，参数更少，效率更高。Transformer2展示了不同LLM架构和模式的多功能性，包括视觉语言任务。Transformer2代表了一次重大的飞跃，它提供了一种可扩展、高效的解决方案，用于增强LLM的适应性和特定任务的性能，为真正动态、自组织的人工智能系统铺平了道路。代码在 https://github.com/SakanaAI/self-adaptive-llms </div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/newlogo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Serge Wang</div><div class="author-info-description">今日事，今日毕</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SergeWang"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/SergeWang" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:sergew027@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome to my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">2.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">相关工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E4%B8%8A%E4%B8%8B%E6%96%87LLMs"><span class="toc-number">3.1.</span> <span class="toc-text">长上下文LLMs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E9%95%BF%E4%B8%8A%E4%B8%8B%E6%96%87%E6%8E%A8%E7%90%86%E7%9A%84KV%E7%BC%93%E5%AD%98%E5%8E%8B%E7%BC%A9"><span class="toc-number">3.2.</span> <span class="toc-text">用于长上下文推理的KV缓存压缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%BB%E7%BA%BF%EF%BC%9A%E8%81%9A%E7%B1%BB%E9%94%AE"><span class="toc-number">4.1.</span> <span class="toc-text">离线：聚类键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%84%9F%E7%9F%A5%E9%94%AE%E6%A3%80%E7%B4%A2"><span class="toc-number">4.2.</span> <span class="toc-text">在线：查询感知键检索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E8%B4%A8%E5%BF%83%E6%9F%A5%E6%89%BE"><span class="toc-number">4.3.</span> <span class="toc-text">分层质心查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">4.4.</span> <span class="toc-text">复杂性分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">系统实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A8%E5%BF%83%E6%9F%A5%E6%89%BE"><span class="toc-number">5.1.</span> <span class="toc-text">质心查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E7%B4%A2%E9%94%AE%E7%9A%84%E7%A8%80%E7%96%8F%E6%B3%A8%E6%84%8F%E5%8A%9B"><span class="toc-number">5.2.</span> <span class="toc-text">检索键的稀疏注意力</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E4%B8%8A%E4%B8%8B%E6%96%87%E5%A4%84%E7%90%86%E5%9F%BA%E5%87%86"><span class="toc-number">6.</span> <span class="toc-text">固定上下文处理基准</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">7.</span> <span class="toc-text">结论</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%94%E5%8D%81%E4%BA%94%EF%BC%9ATransformer2%EF%BC%9A%E8%87%AA%E9%80%82%E5%BA%94LLMs/" title="论文阅读五十五：Transformer2：自适应LLMs"><img src="/images/transformer2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读五十五：Transformer2：自适应LLMs"/></a><div class="content"><a class="title" href="/2025/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%94%E5%8D%81%E4%BA%94%EF%BC%9ATransformer2%EF%BC%9A%E8%87%AA%E9%80%82%E5%BA%94LLMs/" title="论文阅读五十五：Transformer2：自适应LLMs">论文阅读五十五：Transformer2：自适应LLMs</a><time datetime="2025-01-15T07:54:31.000Z" title="发表于 2025-01-15 15:54:31">2025-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%94%E5%8D%81%E5%9B%9B%EF%BC%9ATitans%EF%BC%9A%E5%9C%A8%E6%B5%8B%E8%AF%95%E6%97%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BF%86/" title="论文阅读五十四：Titans：在测试时学习记忆"><img src="/images/titans.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读五十四：Titans：在测试时学习记忆"/></a><div class="content"><a class="title" href="/2025/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%94%E5%8D%81%E5%9B%9B%EF%BC%9ATitans%EF%BC%9A%E5%9C%A8%E6%B5%8B%E8%AF%95%E6%97%B6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BF%86/" title="论文阅读五十四：Titans：在测试时学习记忆">论文阅读五十四：Titans：在测试时学习记忆</a><time datetime="2025-01-15T07:29:34.000Z" title="发表于 2025-01-15 15:29:34">2025-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%94%E5%8D%81%E4%B8%89%EF%BC%9AGAN%E5%B7%B2%E6%AD%BB%EF%BC%9BGAN%E4%B8%87%E5%B2%81%EF%BC%81%E7%8E%B0%E4%BB%A3GAN%E5%9F%BA%E7%BA%BF/" title="论文阅读五十三：GAN已死；GAN万岁！现代GAN基线"><img src="/images/R3GAN.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读五十三：GAN已死；GAN万岁！现代GAN基线"/></a><div class="content"><a class="title" href="/2025/01/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%94%E5%8D%81%E4%B8%89%EF%BC%9AGAN%E5%B7%B2%E6%AD%BB%EF%BC%9BGAN%E4%B8%87%E5%B2%81%EF%BC%81%E7%8E%B0%E4%BB%A3GAN%E5%9F%BA%E7%BA%BF/" title="论文阅读五十三：GAN已死；GAN万岁！现代GAN基线">论文阅读五十三：GAN已死；GAN万岁！现代GAN基线</a><time datetime="2025-01-14T21:43:02.000Z" title="发表于 2025-01-15 05:43:02">2025-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%94%E5%8D%81%E4%BA%8C%EF%BC%9A%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E9%AB%98%E6%95%88%E5%BE%AE%E8%B0%83%EF%BC%9A%E7%BB%BC%E8%BF%B0/" title="论文阅读五十二：大模型的参数高效微调：综述"><img src="/images/PEFT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读五十二：大模型的参数高效微调：综述"/></a><div class="content"><a class="title" href="/2024/12/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%94%E5%8D%81%E4%BA%8C%EF%BC%9A%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%82%E6%95%B0%E9%AB%98%E6%95%88%E5%BE%AE%E8%B0%83%EF%BC%9A%E7%BB%BC%E8%BF%B0/" title="论文阅读五十二：大模型的参数高效微调：综述">论文阅读五十二：大模型的参数高效微调：综述</a><time datetime="2024-12-19T05:36:50.000Z" title="发表于 2024-12-19 13:36:50">2024-12-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%94%E5%8D%81%E4%B8%80%EF%BC%9AReFT%EF%BC%9A%E5%BC%BA%E5%8C%96%E5%BE%AE%E8%B0%83%E6%8E%A8%E7%90%86/" title="论文阅读五十一：ReFT：强化微调推理"><img src="/images/ReFT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文阅读五十一：ReFT：强化微调推理"/></a><div class="content"><a class="title" href="/2024/12/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%BA%94%E5%8D%81%E4%B8%80%EF%BC%9AReFT%EF%BC%9A%E5%BC%BA%E5%8C%96%E5%BE%AE%E8%B0%83%E6%8E%A8%E7%90%86/" title="论文阅读五十一：ReFT：强化微调推理">论文阅读五十一：ReFT：强化微调推理</a><time datetime="2024-12-17T11:56:17.000Z" title="发表于 2024-12-17 19:56:17">2024-12-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Serge Wang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>